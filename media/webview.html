<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vibe Coding Chat</title>
    <!-- Include style and script from media/prism.css, media/prism.js -->
    <link rel="stylesheet" href="%PRISM_PATH%" />
    <!-- Link to the Prism CSS for syntax highlighting -->
    <link rel="stylesheet" href="%STYLES_PATH%" />
  </head>

  <body>
    <div id="header" class="header">
      <div class="logo" id="logo">
        <img src="%LOGO_NAV_PATH%" alt="Logo" />
      </div>
      <div id="header-controls" class="header-controls">
        <button
          id="button-workspace"
          class="btn-elegant"
          style="height: 32px; font-size: 12px"
        >
          Teach AI ðŸ”„
        </button>
        <button
          id="newChatButton"
          class="btn-elegant"
          style="height: 32px; padding: 0 10px; margin-left: 5px"
          title="New Chat"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-4 w-4 pointer-events-none"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M12 4v16m8-8H4"
            />
          </svg>
        </button>
        <button
          id="historyButton"
          class="btn-elegant"
          style="height: 32px; padding: 0 10px; margin-left: 5px"
          title="History"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-4 w-4 pointer-events-none"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
            />
          </svg>
        </button>
        <button
          id="logoutButton"
          class="btn-elegant"
          style="height: 32px; padding: 0 10px; margin-left: 5px"
          title="Logout"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-4 w-4 pointer-events-none"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"
            />
          </svg>
        </button>
      </div>
    </div>
    <div id="content" class="content custom-scrollbar"></div>
    <div id="message" class="message"></div>
    <!-- Removed fixed positioning, now part of flex flow -->
    <div id="messageInputContainer" class="message-input-container">
      <div class="flex items-center mb-2 justify-between">
        <div class="flex items-center">
          <select
            id="modeSelect"
            class="bg-gray-800 text-white text-sm border border-gray-600 rounded p-1 focus:outline-none focus:ring-1 focus:ring-blue-500"
          >
            <option value="agent">ðŸ§  Agent Mode</option>
            <option value="chat">ðŸ’¬ Chat Mode</option>
          </select>
          <button
            id="planButton"
            style="
              margin-left: 8px;
              background-color: #21262d;
              color: #c9d1d9;
              font-size: 0.875rem;
              border: 1px solid #30363d;
              border-radius: 6px;
              padding: 4px 8px;
              cursor: pointer;
              display: none;
            "
            onmouseover="this.style.backgroundColor = '#30363d'"
            onmouseout="this.style.backgroundColor = '#21262d'"
            title="Show Plan Status"
          >
            ðŸ“‹ Plan
          </button>
        </div>
      </div>
      <div
        id="attachment-preview"
        class="flex flex-wrap gap-2 mb-2 hidden"
      ></div>

      <!-- ADDED: Plan Status Container above input -->
      <div
        id="planStatusContainer"
        class="hidden mb-2 p-2 bg-gray-900 border border-gray-700 rounded text-xs text-gray-300 max-h-32 overflow-y-auto"
      >
        <div class="flex justify-between items-center mb-1">
          <span class="font-bold text-blue-400">Current Plan</span>
          <button id="closePlanStatus" class="text-gray-500 hover:text-white">
            &times;
          </button>
        </div>
        <div id="planStatusContent" class="whitespace-pre-wrap"></div>
      </div>

      <div id="composerRow" class="flex items-center">
        <input
          type="file"
          id="file-input"
          multiple
          class="hidden"
          style="display: none"
        />
        <button
          id="attach-button"
          class="btn-elegant mr-2 p-2 rounded-lg flex items-center justify-center"
          style="width: 40px; height: 40px"
          title="Attach files"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"
            />
          </svg>
        </button>
        <textarea
          id="messageInput"
          placeholder="Describe a task for the Agentâ€¦"
          class="flex-grow p-2 border-0 focus:outline-none bg-black text-white"
          style="
            border: none;
            outline: none;
            box-shadow: none;
            resize: none;
            overflow-y: auto;
          "
          rows="1"
        >
        </textarea>
        <button
          id="sendMessageButton"
          class="ml-2 flex items-center justify-center bg-blue-500 hover:bg-blue-600 text-white rounded"
        >
          <div id="button-send" class="button-send">
            <svg class="h-4 w-4 ml-1" fill="currentColor" viewBox="0 0 24 24">
              <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" />
            </svg>
          </div>
          <div id="button-stop" class="hidden">
            <svg class="h-4 w-4" fill="currentColor" viewBox="0 0 24 24">
              <rect x="6" y="6" width="12" height="12" />
            </svg>
          </div>
          <svg id="loader" class="loader hidden" viewBox="0 0 24 24">
            <circle
              class="path"
              cx="12"
              cy="12"
              r="10"
              fill="none"
              stroke-width="4"
            />
          </svg>
        </button>
      </div>
      <div class="flex">
        <div id="div-code-selected" class="flex mt-2"></div>
        <div id="generating" class="mt-2 ml-2 border border-1 p-2"></div>
      </div>
    </div>
    <!-- Plan Status Popup -->
    <div
      id="planPopup"
      style="
        position: fixed;
        background-color: #1a1d23;
        border: 1px solid #30363d;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        padding: 8px;
        max-width: 320px;
        max-height: 256px;
        overflow-y: auto;
        display: none;
        z-index: 9999;
      "
    >
      <div id="planContent" style="font-size: 0.875rem; color: #c9d1d9"></div>
    </div>

    <!-- History Popup -->
    <div
      id="historyPopup"
      style="
        position: fixed;
        top: 48px;
        right: 10px;
        background-color: #1a1d23;
        border: 1px solid #30363d;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        padding: 0;
        width: 300px;
        max-height: 400px;
        overflow-y: auto;
        display: none;
        z-index: 9999;
      "
    >
      <div
        class="p-4 border-b border-gray-700 font-bold text-gray-300 flex justify-between items-center"
        style="padding: 12px 16px"
      >
        <span>Chat History</span>
        <button
          id="closeHistory"
          class="text-white hover:text-white"
          style="
            background: transparent;
            border: none;
            cursor: pointer;
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
          "
        >
          &times;
        </button>
      </div>
      <div id="historyList" class="flex flex-col">
        <!-- History items will be injected here -->
        <div class="p-4 text-center text-gray-500 text-sm">
          No history found
        </div>
      </div>
    </div>
    <script type="module">
      var isLoading = false;
      var messageArray = [];
      var changeStack = []; // Stack to track code changes
      var pendingMessage = null;
      var pendingAttachments = null;
      var isWorkspaceDirty = false;
      var talkDuration = 0;
      var talkMessage = "";
      var workspaces = "";
      var lastSentMessage = "";
      var abortController = null;
      var agentAbortController = null;

      var attachments = [];

      const vscode = acquireVsCodeApi();
      const persistedState = vscode.getState() || {};

      var currentSessionId = Date.now().toString(); // Default session ID

      // Store file contents for diffing
      window.fileContentMap = new Map();

      // Store file paths for caching search results
      window.filePathCache = new Map();

      function saveState() {
        vscode.setState({
          messagesHTML: document.getElementById("content").innerHTML,
          input: document.getElementById("messageInput")?.value ?? "",
          token: localStorage.getItem("token"),
          userId: localStorage.getItem("userId"),
          messages: messageArray,
          mode: document.getElementById("modeSelect")?.value ?? "agent",
          currentSessionId: currentSessionId,
          filePathCache: Array.from(window.filePathCache.entries()), // Persist cache
          fileContentMap: Array.from(window.fileContentMap.entries()), // Persist file content
        });

        // Also trigger save history to extension if we have messages
        if (messageArray.length > 0) {
          saveCurrentChatToHistory();
        }
      }

      function saveCurrentChatToHistory() {
        const title =
          messageArray.length > 0
            ? messageArray[0].content.substring(0, 30) + "..."
            : "New Chat";

        const historyItem = {
          id: currentSessionId,
          title: title,
          timestamp: Date.now(),
          messages: messageArray,
          mode: document.getElementById("modeSelect")?.value ?? "agent",
        };

        // Optimistically update local history if available
        if (window.chatHistory) {
          const existingIndex = window.chatHistory.findIndex(
            (h) => h.id === currentSessionId,
          );
          if (existingIndex >= 0) {
            window.chatHistory[existingIndex] = historyItem;
          } else {
            window.chatHistory.unshift(historyItem); // Add to top
          }
          // Trim history if too long?
          if (window.chatHistory.length > 50) {
            window.chatHistory = window.chatHistory.slice(0, 50);
          }
        }

        vscode.postMessage({
          type: "saveHistoryItem",
          item: historyItem,
        });
      }

      function startNewChat(skipSave = false) {
        try {
          if (isLoading) {
            // Force stop if user confirmed new chat while loading
            isLoading = false;
            if (agentAbortController) {
              agentAbortController.abort();
              agentAbortController = null;
            }
            const btnStop = document.getElementById("button-stop");
            const btnSend = document.getElementById("button-send");
            const loader = document.getElementById("loader");
            if (btnStop) btnStop.classList.add("hidden");
            if (btnSend) btnSend.classList.remove("hidden");
            if (loader) loader.classList.add("hidden");
          }

          if (messageArray.length > 0 && !skipSave) {
            try {
              saveCurrentChatToHistory();
            } catch (e) {
              console.error("Failed to save history:", e);
            }
          }

          // Reset state
          currentSessionId = Date.now().toString();
          messageArray = [];
          const content = document.getElementById("content");
          if (content) content.innerHTML = "";
          const msgInput = document.getElementById("messageInput");
          if (msgInput) msgInput.value = "";
          const generating = document.getElementById("generating");
          if (generating) generating.innerHTML = "";

          // Clear attachments
          attachments = [];
          renderAttachments();

          // Reset plan button and status
          const planButton = document.getElementById("planButton");
          if (planButton) planButton.style.display = "none";
          const planStatusContainer = document.getElementById(
            "planStatusContainer",
          );
          if (planStatusContainer) planStatusContainer.classList.add("hidden");
          const planStatusContent =
            document.getElementById("planStatusContent");
          if (planStatusContent) planStatusContent.innerHTML = "";

          saveState();
        } catch (e) {
          console.error("Error in startNewChat:", e);
          vscode.postMessage({
            command: "error",
            error: "Failed to reset chat: " + e.message,
          });
        }
      }

      function loadHistorySession(sessionId) {
        const session = window.chatHistory.find((h) => h.id === sessionId);
        if (!session) return;

        if (isLoading) {
          if (!confirm("Agent is working. Stop and load history?")) return;
          isLoading = false;
          if (agentAbortController) {
            agentAbortController.abort();
            agentAbortController = null;
          }
          const btnStop = document.getElementById("button-stop");
          const btnSend = document.getElementById("button-send");
          const loader = document.getElementById("loader");
          if (btnStop) btnStop.classList.add("hidden");
          if (btnSend) btnSend.classList.remove("hidden");
          if (loader) loader.classList.add("hidden");
        }

        // Save current before switching?
        if (messageArray.length > 0) {
          saveCurrentChatToHistory();
        }

        currentSessionId = session.id;
        messageArray = session.messages || [];

        // Re-render messages
        const contentDiv = document.getElementById("content");
        contentDiv.innerHTML = "";

        messageArray.forEach((msg) => {
          if (msg.isHidden) return;
          // We need to re-render bubbles.
          // Since we don't have the HTML stored in history (only content), we use displayMessagesAssistant/User
          // But those functions append to DOM.

          if (msg.role === "user") {
            const uniqueId = Date.now() + Math.random();
            displayMessagesAssistant({
              role: "user",
              content: msg.content,
              uniqueId,
            });
          } else {
            const uniqueId = Date.now() + Math.random();
            displayMessagesAssistant({
              role: "assistant",
              content: msg.content,
              uniqueId,
            });
          }
        });

        // Restore mode
        const modeSelect = document.getElementById("modeSelect");
        if (modeSelect && session.mode) {
          modeSelect.value = session.mode;
        }

        // Hide history popup
        document.getElementById("historyPopup").style.display = "none";
        saveState();
      }

      function deleteHistorySession(sessionId) {
        if (!window.chatHistory) return;
        window.chatHistory = window.chatHistory.filter(
          (h) => h.id !== sessionId,
        );
        vscode.postMessage({
          type: "deleteHistoryItem",
          id: sessionId,
        });
        renderHistoryList();
        // If deleted current session, start new chat?
        if (sessionId === currentSessionId) {
          startNewChat(true);
        }
      }

      function renderHistoryList() {
        const listContainer = document.getElementById("historyList");
        listContainer.innerHTML = "";

        if (!window.chatHistory || window.chatHistory.length === 0) {
          listContainer.innerHTML =
            '<div class="p-4 text-center text-gray-500 text-sm">No history found</div>';
          return;
        }

        window.chatHistory.forEach((item) => {
          const date = new Date(item.timestamp).toLocaleString();
          const div = document.createElement("div");
          div.className = "history-item group";
          div.onclick = () => loadHistorySession(item.id);

          const infoDiv = document.createElement("div");
          infoDiv.className = "history-info";

          const title = document.createElement("span");
          title.className = "history-title";
          title.textContent = item.title || "Untitled Chat";

          const meta = document.createElement("span");
          meta.className = "history-date";
          meta.textContent = date;

          infoDiv.appendChild(title);
          infoDiv.appendChild(meta);

          // Delete button
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "history-delete-btn";
          deleteBtn.title = "Delete Chat";
          deleteBtn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
          `;
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            // Removed confirm dialog as it might block the webview
            deleteHistorySession(item.id);
          };

          div.appendChild(infoDiv);
          div.appendChild(deleteBtn);
          listContainer.appendChild(div);
        });
      }

      // Auto-resize textarea
      const messageInput = document.getElementById("messageInput");
      messageInput.addEventListener("input", function () {
        this.style.height = "auto";
        this.style.height = this.scrollHeight + "px";
        // Max height constraint handled by CSS
        if (this.value === "") {
          this.style.height = "auto";
        }
      });

      document.addEventListener("DOMContentLoaded", function () {
        // Always request history on load to ensure window.chatHistory is populated
        vscode.postMessage({ type: "getHistory" });

        const token = localStorage.getItem("token");
        const userId = localStorage.getItem("userId");
        const modeSelect = document.getElementById("modeSelect");
        const messageInput = document.getElementById("messageInput");
        function updatePlaceholder() {
          const mode = modeSelect ? modeSelect.value : "agent";
          if (mode === "agent") {
            messageInput.placeholder = "Describe a task for the Agentâ€¦";
          } else {
            messageInput.placeholder = "Ask a question or start chattingâ€¦";
          }
        }
        if (modeSelect) {
          modeSelect.addEventListener("change", updatePlaceholder);
        }
        updatePlaceholder();
        if (token && userId) {
          vscode.postMessage({ type: "validateToken", token, userId });
        } else {
          // Clear state if no token
          vscode.setState(undefined);
          showLoginForm();
        }
        const sendMessageButton = document.getElementById("sendMessageButton");
        sendMessageButton.addEventListener("click", handleSendMessage);
        const btnWorkspace = document.getElementById("button-workspace");
        btnWorkspace.addEventListener("click", updateWorkspaces);
        const logoutButton = document.getElementById("logoutButton");
        logoutButton.addEventListener("click", logout);

        const newChatButton = document.getElementById("newChatButton");
        if (newChatButton) {
          newChatButton.addEventListener("click", () => {
            // Remove confirm for now to test if it's blocking
            // if (confirm("Start a new chat? Current chat will be saved to history.")) {
            try {
              startNewChat();
            } catch (e) {
              console.error("Error starting new chat:", e);
              vscode.postMessage({
                command: "error",
                error: "Failed to start new chat: " + e.message,
              });
            }
            // }
          });
        }

        const historyButton = document.getElementById("historyButton");
        const historyPopup = document.getElementById("historyPopup");
        const closeHistoryBtn = document.getElementById("closeHistory");

        if (historyButton && historyPopup) {
          historyButton.addEventListener("click", () => {
            if (historyPopup.style.display === "none") {
              // Request latest history
              vscode.postMessage({ type: "getHistory" });
              historyPopup.style.display = "block";
            } else {
              historyPopup.style.display = "none";
            }
          });

          // Close when clicking outside
          document.addEventListener("click", (e) => {
            if (
              historyPopup &&
              !historyPopup.contains(e.target) &&
              !historyButton.contains(e.target) &&
              historyPopup.style.display === "block"
            ) {
              historyPopup.style.display = "none";
            }
          });
        }

        if (closeHistoryBtn) {
          closeHistoryBtn.addEventListener("click", () => {
            historyPopup.style.display = "none";
          });
        }

        // Plan Button Logic
        const planButton = document.getElementById("planButton");
        const planStatusContainer = document.getElementById(
          "planStatusContainer",
        );
        const closePlanStatus = document.getElementById("closePlanStatus");

        if (planButton) {
          planButton.addEventListener("click", togglePlanPopup);
        }

        if (closePlanStatus && planStatusContainer) {
          closePlanStatus.addEventListener("click", () => {
            planStatusContainer.classList.add("hidden");
          });
        }

        messageInput.value = messageInput.value.trim();

        messageInput.addEventListener("keydown", handleKeyDown);

        // Attachment Logic
        const fileInput = document.getElementById("file-input");
        const attachButton = document.getElementById("attach-button");
        const preview = document.getElementById("attachment-preview");
        const dropZone = document.getElementById("messageInputContainer");

        attachButton.addEventListener("click", () => fileInput.click());
        fileInput.addEventListener("change", (e) =>
          handleFiles(e.target.files),
        );

        dropZone.addEventListener("dragover", (e) => {
          e.preventDefault();
          dropZone.classList.add("border-blue-500", "border-2");
        });
        dropZone.addEventListener("dragleave", (e) => {
          e.preventDefault();
          dropZone.classList.remove("border-blue-500", "border-2");
        });
        dropZone.addEventListener("drop", (e) => {
          e.preventDefault();
          dropZone.classList.remove("border-blue-500", "border-2");
          handleFiles(e.dataTransfer.files);
        });

        messageInput.addEventListener("paste", (e) => {
          const items = (e.clipboardData || e.originalEvent.clipboardData)
            .items;
          const files = [];
          for (let index in items) {
            const item = items[index];
            if (item.kind === "file") {
              files.push(item.getAsFile());
            }
          }
          if (files.length > 0) {
            e.preventDefault();
            handleFiles(files);
          }
        });

        window.addEventListener("message", async (event) => {
          const messageEvent = event.data;

          if (messageEvent.command === "systemLog") {
            console.log("[SystemLog]", messageEvent.message);
            return;
          }

          if (messageEvent.command == "updateFileInfo") {
            if (messageEvent.filePath) {
              document.getElementById("div-code-selected").innerHTML = `
                                        <div id="fileOpen"
                                            class="flex file-open p-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                            <span id="filePath"></span><span class="fs-6" id="selectedLine"></span>
                                            <span id="svg-eye"></span>
                                        </div>`;

              document.getElementById("filePath").textContent =
                messageEvent.filePath;
              document.getElementById("selectedLine").textContent =
                ": " + messageEvent.selectedLine + " Current file";
              document.getElementById("svg-eye").innerHTML =
                `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" id="eye" fill="white" class="icon">
                                            <path
                                                d="M21.92,11.6C19.9,6.91,16.1,4,12,4S4.1,6.91,2.08,11.6a1,1,0,0,0,0,.8C4.1,17.09,7.9,20,12,20s7.9-2.91,9.92-7.6A1,1,0,0,0,21.92,11.6ZM12,18c-3.17,0-6.17-2.29-7.9-6C5.83,8.29,8.83,6,12,6s6.17,2.29,7.9,6C18.17,15.71,15.17,18,12,18ZM12,8a4,4,0,1,0,4,4A4,4,0,0,0,12,8Zm0,6a2,2,0,1,1,2-2A2,2,0,0,1,12,14Z">
                                            </path>
                                        </svg>`;
            } else {
              document.getElementById("div-code-selected").innerHTML = "";
              document.getElementById("filePath").textContent = "";
              document.getElementById("selectedLine").textContent = "";
              document.getElementById("svg-eye").innerHTML = "";
            }
            return;
          }

          if (messageEvent.command === "filesFound") {
            // console.log(`Files found webview: ${messageEvent.files}`)
            workspaces = messageEvent.files;
            var token = messageEvent.token;
            await loginAPI(workspaces, token);
            return;
            // Handle the list of files as needed
          } else if (messageEvent.command === "error") {
            console.error(`Error: ${messageEvent.error}`);
            return;
          }

          if (messageEvent.command === "filesModified") {
            const changes = messageEvent.changes;
            if (messageArray.length > 0) {
              const lastMsg = messageArray[messageArray.length - 1];
              if (!lastMsg.changes) {
                lastMsg.changes = [];
              }
              lastMsg.changes.push(...changes);
              saveState();
            }
            return;
          }

          if (messageEvent.command === "workspaceCode") {
            // console.log(`Files found webview: ${messageEvent.files}`)
            workspaces = messageEvent.files;
            await updateWorkspacesAPI(workspaces);
            if (window.resolveWorkspaceUpdate) {
              window.resolveWorkspaceUpdate();
              window.resolveWorkspaceUpdate = null;
            }
            return;
            // Handle the list of files as needed
          } else if (messageEvent.command === "error") {
            console.error(`Error: ${messageEvent.error}`);
            return;
          }

          if (messageEvent.command === "workspaceCodeCancel") {
            await cancelUpdateWorkspaces();
            return;
            // Handle the list of files as needed
          } else if (messageEvent.command === "error") {
            console.error(`Error: ${messageEvent.error}`);
            return;
          }

          if (messageEvent.command === "workspaceDirty") {
            isWorkspaceDirty = messageEvent.isDirty;
            const btnWorkspace = document.getElementById("button-workspace");
            if (isWorkspaceDirty) {
              btnWorkspace.innerHTML = `Teach AI Current Code ðŸ”„ (Changes detected)`;
              btnWorkspace.classList.add("bg-yellow-600"); // Visual indicator
            } else {
              btnWorkspace.innerHTML = `Teach AI Current Code ðŸ”„`;
              btnWorkspace.classList.remove("bg-yellow-600");
            }
            return;
          }

          if (messageEvent.command === "historyLoad") {
            window.chatHistory = messageEvent.history || [];
            renderHistoryList();
            return;
          }

          if (messageEvent.command === "tokenValid") {
            localStorage.setItem("token", messageEvent.token);
            localStorage.setItem("userId", messageEvent.userId);

            // Restore file path cache
            if (persistedState.filePathCache) {
              try {
                window.filePathCache = new Map(persistedState.filePathCache);
                console.log(
                  "[webview] Restored file path cache:",
                  window.filePathCache.size,
                  "entries",
                );
              } catch (e) {
                console.error(
                  "[webview] Failed to restore file path cache:",
                  e,
                );
              }
            }

            // Restore file content map
            if (persistedState.fileContentMap) {
              try {
                window.fileContentMap = new Map(persistedState.fileContentMap);
                console.log(
                  "[webview] Restored file content map:",
                  window.fileContentMap.size,
                  "entries",
                );
              } catch (e) {
                console.error(
                  "[webview] Failed to restore file content map:",
                  e,
                );
              }
            }

            // Fetch and display chat history
            if (persistedState.messages && persistedState.messages.length > 0) {
              messageArray = persistedState.messages;
              displayMessages(messageArray);

              document.getElementById("messageInput").value =
                persistedState.input ?? "";
              const modeSelect = document.getElementById("modeSelect");
              if (modeSelect) {
                modeSelect.value = persistedState.mode ?? "agent";
              }
              const messageInputContainer = document.getElementById(
                "messageInputContainer",
              );
              messageInputContainer.style.display = "block";
              var content = document.getElementById("content");
              content.scrollTop = content.scrollHeight;
              const messageInput = document.getElementById("messageInput");
              messageInput.style.height = "auto";
              messageInput.style.height = messageInput.scrollHeight + "px";
              messageInput.focus();
            } else if (persistedState.messagesHTML) {
              document.getElementById("content").innerHTML =
                persistedState.messagesHTML;
              document.getElementById("messageInput").value =
                persistedState.input ?? "";
              const modeSelect = document.getElementById("modeSelect");
              if (modeSelect) {
                modeSelect.value = persistedState.mode ?? "agent";
              }
              // Show the message input container
              const messageInputContainer = document.getElementById(
                "messageInputContainer",
              );
              messageInputContainer.style.display = "block";

              // Re-attach event listeners for buttons since innerHTML destroys them
              reattachEventListeners();

              var content = document.getElementById("content");
              // Scroll to the bottom of the content
              content.scrollTop = content.scrollHeight;
              const messageInput = document.getElementById("messageInput");
              // Trigger resize
              messageInput.style.height = "auto";
              messageInput.style.height = messageInput.scrollHeight + "px";
              messageInput.focus();
            } else {
              fetchHistory();
            }
            return;
            // Handle the list of files as needed
          } else if (messageEvent.command === "error") {
            console.error(`Error: ${messageEvent.error}`);
            return;
          }

          if (messageEvent.command === "tokenInvalid") {
            logout();
            return;
            // Handle the list of files as needed
          } else if (messageEvent.command === "error") {
            console.error(`Error: ${messageEvent.error}`);
            return;
          }

          // Ignore other commands that fell through
          if (messageEvent.command) {
            return;
          }

          // Legacy handling for messages without command - now handled in handleSendMessage via explicit listener
          return;
        });
      });

      function handleFiles(files) {
        if (!files || files.length === 0) return;
        const fileInput = document.getElementById("file-input");
        Array.from(files).forEach((file) => {
          const reader = new FileReader();
          reader.onload = (e) => {
            const content = e.target.result;
            const attachment = {
              name: file.name,
              type: file.type,
              content: content,
            };
            attachments.push(attachment);
            renderAttachments();
          };
          reader.readAsDataURL(file);
        });
        if (fileInput) fileInput.value = "";
      }

      function renderAttachments() {
        const preview = document.getElementById("attachment-preview");
        if (!preview) return;

        preview.innerHTML = "";
        if (attachments.length > 0) {
          preview.classList.remove("hidden");
        } else {
          preview.classList.add("hidden");
        }

        attachments.forEach((att, index) => {
          const div = document.createElement("div");
          div.className =
            "relative group bg-gray-800 rounded p-1 border border-gray-600 inline-block mr-2";

          if (att.type.startsWith("image/")) {
            const img = document.createElement("img");
            img.src = att.content;
            img.className = "h-8 w-8 object-cover rounded";
            div.appendChild(img);
          } else {
            const span = document.createElement("div");
            span.className =
              "h-8 w-8 flex items-center justify-center text-xs text-center rounded overflow-hidden p-1 break-all text-white";
            span.textContent = att.name;
            div.appendChild(span);
          }

          const removeBtn = document.createElement("button");
          removeBtn.className =
            "absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity text-xs";
          removeBtn.innerHTML = "&times;";
          removeBtn.onclick = () => {
            attachments.splice(index, 1);
            renderAttachments();
          };
          div.appendChild(removeBtn);
          preview.appendChild(div);
        });
      }

      function normalizeAttachments(files) {
        const arr = (files || []).map((att) => {
          const content = att?.content || "";
          const match = /^data:(.*?);base64,(.*)$/.exec(content);
          if (match) {
            const mime = match[1] || att.type || "";
            const base64 = match[2] || "";
            return {
              name: att.name,
              type: mime,
              contentBase64: base64,
              encoding: "base64",
              contentDataUrl: content,
            };
          }
          return {
            name: att.name,
            type: att.type || "",
            contentBase64: content,
            encoding: "base64",
            contentDataUrl: content,
          };
        });
        try {
          console.log(
            "normalizeAttachments",
            arr.map((a) => ({
              name: a.name,
              type: a.type,
              len: a.contentBase64?.length || 0,
            })),
          );
        } catch (e) {}
        return arr;
      }

      function handleKeyDown(event) {
        if (event.key === "Enter" && !event.shiftKey) {
          event.preventDefault();
          handleSendMessage();
        } else {
          this.style.height = "auto"; // Reset tinggi agar bisa menghitung tinggi yang baru
          this.style.height = Math.min(this.scrollHeight, 300) + "px"; // Set tinggi maksimal 300px
        }
      }

      async function handleSendMessage() {
        if (isLoading) {
          stopGeneration();
          return;
        }

        const messageInput = document.getElementById("messageInput");
        const messageVal = messageInput.value.trim();
        if (!messageVal) return;

        lastSentMessage = messageVal;

        document.getElementById("generating").innerHTML = "Generating...";
        const sendMessageButton = document.getElementById("button-send");
        const stopButton = document.getElementById("button-stop");
        const newChatButton = document.getElementById("newChatButton");
        const historyButton = document.getElementById("historyButton");

        sendMessageButton.classList.add("hidden");
        stopButton.classList.remove("hidden");

        if (newChatButton) newChatButton.disabled = true;
        if (historyButton) historyButton.disabled = true;

        console.log("send message to Vibe Coding");

        // Wait for response from extension
        const response = await new Promise((resolve) => {
          const handler = (event) => {
            const msg = event.data;
            if (msg.command === "selectedTextResponse") {
              window.removeEventListener("message", handler);
              resolve(msg);
            }
          };
          window.addEventListener("message", handler);
          vscode.postMessage({ command: "getSelectedText" });

          // Fallback timeout
          setTimeout(() => {
            window.removeEventListener("message", handler);
            resolve({ text: "", allCode: "" });
          }, 2000);
        });

        const coding = response.text || "";
        const allCode = response.allCode || "";

        const allCodeStorageKey = "allCodeStorage";
        const codingStorageKey = "codingStorage";
        const storedAllCode = localStorage.getItem(allCodeStorageKey);
        const storedCoding = localStorage.getItem(codingStorageKey);

        if (allCode && storedAllCode !== allCode) {
          localStorage.setItem(allCodeStorageKey, allCode);
          console.log("All code saved to local storage.");
        }
        if (coding && storedCoding !== coding) {
          localStorage.setItem(codingStorageKey, coding);
          console.log("Coding saved to local storage.");
        }

        let message = messageVal;
        const modeSelect = document.getElementById("modeSelect");
        const mode = modeSelect ? modeSelect.value : "agent";

        if (coding && mode !== "agent") {
          message =
            "[labelInstruction]Instruction: [labelInstruction]" +
            message +
            "[selection]" +
            coding +
            "[selection]";
        }
        if (allCode && mode !== "agent") {
          message = "[fullcode]" + allCode + "[fullcode]" + message;
        }

        console.log("send message to API");
        if (!message) return;
        sendMessageToApi(message);
      }

      function stopGeneration() {
        if (abortController) {
          abortController.abort();
          abortController = null;
        }
        if (agentAbortController) {
          try {
            agentAbortController.abort();
          } catch (e) {}
          agentAbortController = null;
        }

        // Notify extension to abort any running tasks
        vscode.postMessage({ command: "abort" });

        // Dispatch event for internal listeners
        window.dispatchEvent(new Event("agent-stop"));

        isLoading = false;

        const sendMessageButton = document.getElementById("button-send");
        const stopButton = document.getElementById("button-stop");
        const loader = document.getElementById("loader");
        const messageInput = document.getElementById("messageInput");
        const newChatButton = document.getElementById("newChatButton");
        const historyButton = document.getElementById("historyButton");

        sendMessageButton.classList.remove("hidden");
        stopButton.classList.add("hidden");
        loader.classList.add("hidden");

        if (newChatButton) newChatButton.disabled = false;
        if (historyButton) historyButton.disabled = false;

        messageInput.value = lastSentMessage;
        messageInput.style.height = "auto";
        messageInput.style.height = messageInput.scrollHeight + "px";
        messageInput.disabled = false;
        messageInput.focus();

        document.getElementById("generating").innerHTML = "Stopped.";
        setTimeout(() => {
          if (!isLoading) document.getElementById("generating").innerHTML = "";
        }, 2000);
      }

      async function sendMessageToApi(message, isRetry = false) {
        if (isLoading && !isRetry) return; // Allow retry to proceed if called internally
        isLoading = true;

        // Setup AbortController
        abortController = new AbortController();

        const messageInput = document.getElementById("messageInput");

        // Clear input immediately
        if (!isRetry) {
          messageInput.value = "";
          messageInput.style.height = "auto";
        }

        messageInput.disabled = true;
        document.getElementById("generating").innerHTML = "Generating...";

        const uniqueId = Date.now() + Math.random();

        // Clone attachments for this message
        if (isRetry && pendingAttachments) {
          attachments = pendingAttachments;
        }
        const currentAttachments = [...attachments];
        const normalizedAttachments = normalizeAttachments(currentAttachments);
        try {
          console.log(
            "sending attachments",
            normalizedAttachments.map((a) => ({
              name: a.name,
              type: a.type,
              len: a.contentBase64?.length || 0,
            })),
          );
        } catch (e) {}

        let displayMessage = message;
        if (currentAttachments.length > 0) {
          const tokens = currentAttachments.map((a) => {
            const isImg = (a.type || "").startsWith("image/");
            const src = a.contentDataUrl || a.content || "";
            if (isImg && src) {
              return `[att-img name="${a.name.replace(/"/g, "")}" src="${src.replace(/"/g, "%22")}"]`;
            }
            return `[att-file name="${a.name.replace(/"/g, "")}"]`;
          });
          displayMessage += "\n\n" + tokens.join(" ");
        }

        if (!isRetry) {
          // add the â€œuserâ€ bubble
          displayMessagesAssistant({
            role: "user",
            content: displayMessage,
            uniqueId,
          });
          //save message
          messageArray.push({ role: "user", content: displayMessage });
          saveState();
        }

        // add an empty â€œassistantâ€ bubble that weâ€™ll update
        displayMessagesAssistant({
          role: "assistant",
          content: "",
          uniqueId: `assistant-${uniqueId}`,
        });

        const modeSelect = document.getElementById("modeSelect");
        const mode = modeSelect ? modeSelect.value : "agent";

        // NEW: Check if workspace is dirty before sending
        if (mode === "agent" && isWorkspaceDirty && !isRetry) {
          console.log("Workspace is dirty, auto-updating...");

          // Show a temporary bubble or just the loader?
          // Let's use the pending message logic
          pendingMessage = message;
          pendingAttachments = currentAttachments;

          // Remove the user bubble we just added to avoid duplication on retry?
          // Actually, if we just stop here, the user bubble is already in messageArray.
          // When retry happens, isRetry=true, so we won't add it again.
          // But we need to make sure the assistant bubble is ready or removed.
          // The assistant bubble is added above.
          // Let's remove the assistant bubble so it doesn't look stuck
          const bubble = document.getElementById(`assistant-${uniqueId}`);
          if (bubble) bubble.parentElement.remove();

          await updateWorkspaces(true); // Silent update
          return;
        }

        if (mode === "agent") {
          // Clear attachments immediately after sending (but keep snapshot for this request)
          const snapshot = normalizedAttachments;
          attachments = [];
          renderAttachments();
          // Setup AbortController for agent workflow
          agentAbortController = new AbortController();
          try {
            await handleAgentWorkflow(message, uniqueId, snapshot);
          } catch (err) {
            if (err.name !== "AbortError") {
              console.error("Agent workflow error:", err);
            }
          }
          return;
        }

        const data = {
          userId: localStorage.getItem("userId"),
          token: localStorage.getItem("token"),
          message,
          mode: mode,
          attachments: normalizedAttachments,
        };

        // Clear attachments
        attachments = [];
        renderAttachments();

        try {
          const response = await fetch("http://localhost:13100/api/message", {
            method: "POST",
            headers: {
              Authorization: `Bearer ${data.token}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify(data),
            signal: abortController.signal,
          });

          if (!response.ok) {
            const clone = response.clone();
            try {
              const errJson = await clone.json();
              if (errJson.error === "WORKSPACE_MISSING") {
                console.log("Workspace missing, triggering auto-scan...");

                // Remove the empty assistant bubble we just added
                const bubble = document.getElementById(`assistant-${uniqueId}`);
                if (bubble) bubble.parentElement.remove();

                pendingMessage = message; // Save for retry
                pendingAttachments = currentAttachments;
                await updateWorkspaces(true); // Call with silent=true
                return;
              }
            } catch (e) {
              console.error(e);
            }

            throw new Error("Failed to send message");
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let assistantMessage = "";

          var no = 0;
          // read the stream
          while (true) {
            messageInput.value = "";
            const { value, done } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            assistantMessage += chunk;

            // update the existing assistant bubble
            updateMessagesAssistant({
              uniqueId: `assistant-${uniqueId}`,
              content: assistantMessage,
            });
            if (no == 0) {
              const content = document.getElementById("content");
              content.scrollTop = content.scrollHeight;
            }
            no++;
          }

          console.log("stream finished");
          console.log(assistantMessage);
          // if a write-file command appears, send it immediately
          if (assistantMessage.includes("[writeFile]")) {
            vscode.postMessage({ type: "writeFile", assistantMessage });
          }

          // finalize: save and tidy up UI
          messageArray.push({ role: "assistant", content: assistantMessage });

          const loader = document.getElementById("loader");
          const sendBtn = document.getElementById("button-send");
          const stopBtn = document.getElementById("button-stop");
          const newChatButton = document.getElementById("newChatButton");
          const historyButton = document.getElementById("historyButton");

          loader.classList.add("hidden");
          stopBtn.classList.add("hidden");
          sendBtn.classList.remove("hidden");

          if (newChatButton) newChatButton.disabled = false;
          if (historyButton) historyButton.disabled = false;

          document.getElementById("generating").innerHTML = "";
          saveState();
          setTimeout(() => {
            isLoading = false;
            messageInput.disabled = false; // Enable message input after loading is complete
            messageInput.focus();
          }, 1000);
        } catch (err) {
          if (err.name === "AbortError") {
            console.log("Fetch aborted by user");
            return; // Stop execution here, stopGeneration handled UI
          }
          console.error("Stream error:", err);
          isLoading = false;
          // Restore UI on error
          document.getElementById("loader").classList.add("hidden");
          document.getElementById("button-stop").classList.add("hidden");
          document.getElementById("button-send").classList.remove("hidden");
          document.getElementById("messageInput").disabled = false;

          const newChatButton = document.getElementById("newChatButton");
          const historyButton = document.getElementById("historyButton");
          if (newChatButton) newChatButton.disabled = false;
          if (historyButton) historyButton.disabled = false;
        }
      }

      async function handleAgentWorkflow(
        message,
        uniqueId,
        attachments,
        isRetry = false,
      ) {
        const token = localStorage.getItem("token");
        const userId = localStorage.getItem("userId");
        try {
          console.log(
            "agent attachments",
            (attachments || []).map((a) => ({
              name: a.name,
              type: a.type,
              len: a.contentBase64?.length || 0,
            })),
          );
        } catch (e) {}

        let iteration = 0;
        const MAX_ITERATIONS = 25;
        let currentContext = "";
        let currentModifiedFiles = new Set();
        let currentUniqueId = uniqueId;

        // Helper to read file asynchronously for memory loading
        const readFileAsync = (filePath, timeoutMs = 3000) => {
          return new Promise((resolve) => {
            let handleMessage;
            const timeout = setTimeout(() => {
              window.removeEventListener("message", handleMessage);
              resolve(null); // Resolve null on timeout
            }, timeoutMs);

            handleMessage = (event) => {
              if (
                event.data.command === "readFileResult" &&
                event.data.filePath === filePath
              ) {
                clearTimeout(timeout);
                window.removeEventListener("message", handleMessage);
                if (event.data.error) {
                  resolve(null);
                } else {
                  resolve(event.data.content);
                }
              }
            };
            window.addEventListener("message", handleMessage);
            vscode.postMessage({ type: "readFile", filePath });
          });
        };

        // Try to load project memory and other context files
        try {
          const vicoFiles = [
            "memory.md",
            "architecture.md",
            "style.md",
            "history.md",
            "lessons.md",
          ];
          let memoryFound = false;

          for (const file of vicoFiles) {
            const vicoPath = `.vico/${file}`;
            const content = await readFileAsync(vicoPath);

            if (content) {
              currentContext += `\n=== PROJECT CONTEXT (${vicoPath}) ===\n${content}\n========================================\n`;

              if (
                file === "memory.md" ||
                file === "history.md" ||
                file === "lessons.md"
              ) {
                if (file === "memory.md") memoryFound = true;
                currentContext += `\n=== SYSTEM NOTE ===\nTo update ${vicoPath}, ONLY generate the NEW content to be appended. Do NOT regenerate the entire file.\n===================\n`;
              }

              if (file === "architecture.md" || file === "style.md") {
                currentContext += `\n=== SYSTEM NOTE ===\nTo update ${vicoPath}, you MUST regenerate the ENTIRE content. This file represents the current state of truth.\n===================\n`;
              }

              console.log(`[webview] Loaded project context from ${vicoPath}.`);
            } else if (file === "memory.md") {
              // Fallback for memory.md in root if not in .vico
              const rootMemoryPath = "memory.md";
              const rootMemoryContent = await readFileAsync(rootMemoryPath);
              if (rootMemoryContent) {
                memoryFound = true;
                currentContext += `\n=== PROJECT MEMORY (${rootMemoryPath}) ===\n${rootMemoryContent}\n========================================\n`;
                currentContext += `\n=== SYSTEM NOTE ===\nTo update ${rootMemoryPath}, ONLY generate the NEW content to be appended. Do NOT regenerate the entire file.\n===================\n`;
                console.log(
                  `[webview] Loaded project memory from ${rootMemoryPath}.`,
                );
              }
            }
          }

          if (!memoryFound) {
            // File missing, instruct agent to create it (prefer .vico/memory.md)
            currentContext += `\n=== SYSTEM NOTE ===\nThe memory file .vico/memory.md does not exist. If this is a new project, run the CLI generator FIRST (e.g., npx create-next-app .). Create .vico/memory.md ONLY AFTER the project structure is ready.\n===================\n`;
          }
        } catch (e) {
          console.log(
            "[webview] No project memory found or error reading it:",
            e,
          );
        }

        // Add explicit autonomous behavior instruction
        currentContext += `\n=== CRITICAL INSTRUCTION ===\nYou are an AUTONOMOUS agent. Do NOT ask the user what to do next. You MUST decide the best course of action yourself and proceed to execute it immediately. If there are multiple options, choose the most reasonable one and ACT on it. Do not stop to ask for permission or preference. Complete the user's request end-to-end.\n`;
        currentContext += `\n=== PLANNING & EXECUTION STRATEGY ===\n1. **PHASE 1: PLAN**: At the very beginning, CREATE A COMPREHENSIVE, NUMBERED PLAN. List all steps required to solve the user's request.\n2. **PHASE 2: EXECUTE**: Execute the plan step-by-step. Do not deviate unless a step fails.\n3. **VERIFY**: After applying a fix, you MUST verify it (e.g., run the code, check for errors).\n4. **NO LOOPING**: If a step fails, do not retry the exact same action. Analyze the error and adjust your plan.\n5. **HISTORY AWARENESS**: Review the 'History' to see what steps have already been completed. DO NOT REPEAT COMPLETED STEPS.\n============================\n`;
        currentContext += `\nIMPORTANT: Maintain 'memory.md' as a living history of the project. Record every major user request and your solution steps there. This context is CRITICAL.\n`;
        currentContext += `HOWEVER, you must BALANCE documentation with execution. Do not get stuck in a loop of only updating memory. Every memory update should be accompanied by, or follow, the actual code implementation that solves the user's problem. Log your work, then DO your work. If you have already updated memory for the current task, do not do it again unless new significant information arises. FOCUS ON DELIVERING WORKING CODE.\n============================\n`;
        currentContext += `\n=== FILE STRUCTURE AWARENESS ===\nBefore creating any new file or component, you MUST check the 'PROJECT FILE STRUCTURE' provided in the context. \n- If this is a Next.js project, verify if it uses the 'app/' directory (App Router) or 'pages/' directory (Pages Router). \n- Do NOT create 'pages/index.js' if 'app/page.tsx' exists. \n- Do NOT mix TypeScript (.ts/.tsx) and JavaScript (.js/.jsx) unless the project already does. Follow existing patterns.\n================================\n`;

        // Initial thinking bubble
        updateMessagesAssistant({
          uniqueId: `assistant-${currentUniqueId}`,
          content: "ðŸ§  Thinking & Planning...",
        });

        // === MANDATORY PROJECT STRUCTURE SCAN ===
        try {
          updateMessagesAssistant({
            uniqueId: `assistant-${currentUniqueId}`,
            content: "ðŸ“‚ Scanning project structure...",
          });

          // 1. List Files
          const fileList = await new Promise((resolve) => {
            let handleMessage;
            const timeout = setTimeout(() => {
              window.removeEventListener("message", handleMessage);
              resolve([]); // Return empty list on timeout
            }, 5000);

            handleMessage = (event) => {
              if (event.data.command === "listFilesResult") {
                clearTimeout(timeout);
                window.removeEventListener("message", handleMessage);
                resolve(event.data.files || []);
              }
            };
            window.addEventListener("message", handleMessage);
            vscode.postMessage({ command: "listFiles", pattern: "**/*" });
          });

          if (fileList.length > 0) {
            // Filter for important directories/files to keep context lean but useful
            const crucialFiles = fileList.filter(
              (f) =>
                f.match(
                  /^(package\.json|tsconfig\.json|jsconfig\.json|next\.config\.|vite\.config\.|src\/|app\/|pages\/|components\/|public\/|index\.|main\.)/i,
                ) || f.split("/").length <= 3, // Include root and depth-2 files
            );

            // If crucial files are too few, just take top 200 of everything
            const filesToContext =
              crucialFiles.length > 0 ? crucialFiles : fileList.slice(0, 200);

            currentContext += `\n=== PROJECT FILE STRUCTURE (Scanned) ===\n${filesToContext.join("\n")}\n========================================\n`;
            console.log(
              "[webview] Scanned project structure:",
              filesToContext.length,
              "files",
            );

            // 2. Read package.json if exists
            if (fileList.includes("package.json")) {
              const pkgContent = await readFileAsync("package.json");
              if (pkgContent) {
                currentContext += `\n=== package.json ===\n${pkgContent}\n====================\n`;
              }
            }

            // 3. Read tsconfig.json if exists
            if (fileList.includes("tsconfig.json")) {
              const tsConfigContent = await readFileAsync("tsconfig.json");
              if (tsConfigContent) {
                currentContext += `\n=== tsconfig.json ===\n${tsConfigContent}\n=====================\n`;
              }
            }
          }

          // Restore "Thinking" status
          updateMessagesAssistant({
            uniqueId: `assistant-${currentUniqueId}`,
            content: "ðŸ§  Thinking & Planning...",
          });
        } catch (scanError) {
          console.error("Project scan failed:", scanError);
          // Continue without scan if it fails
        }

        currentContext += `\n=== ANTI-PATTERNS (STRICTLY FORBIDDEN) ===\n1. **NO EMPTY SCAFFOLDING**: Do NOT create empty folders or '.gitkeep' files. If you need a folder, create it by writing a REAL file inside it (e.g., 'components/Navbar.tsx', not just 'components/').\n2. **NO PLACEHOLDERS**: Do NOT write files with "// TODO: implement". Write the ACTUAL code requested.\n3. **NO HALLUCINATED COMPLETION**: Do not say "Task Completed" if you have only created folders. You must write the functional code.\n==========================================\n`;

        // Initialize global plan state if starting new workflow
        if (iteration === 1) {
          window.currentPlanMarkdown = "";
        }

        while (iteration < MAX_ITERATIONS) {
          if (!isLoading) {
            updateMessagesAssistant({
              uniqueId: `assistant-${currentUniqueId}`,
              content: "Stopped.",
            });
            break;
          }
          iteration++;

          // ... (existing bubble creation code) ...

          if (iteration > 1) {
            currentUniqueId = Date.now() + Math.random();
            displayMessagesAssistant({
              role: "assistant",
              content: "",
              uniqueId: `assistant-${currentUniqueId}`,
            });
            updateMessagesAssistant({
              uniqueId: `assistant-${currentUniqueId}`,
              content: `ðŸ§  Thinking & Planning (Step ${iteration})...`,
            });
          }

          try {
            // 1. Request Plan
            const response = await fetch(
              "http://localhost:13100/api/agent/plan",
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  userId,
                  token,
                  message,
                  attachments,
                  history: messageArray,
                  context: currentContext, // Pass accumulated context
                }),
                signal: agentAbortController?.signal,
              },
            );

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let planJson = "";

            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              const chunk = decoder.decode(value, { stream: true });
              planJson += chunk;
            }

            let planData;
            try {
              // Find JSON in the response (robust extraction)
              let jsonString = planJson;

              // 1. Try to extract from markdown code block first
              const markdownMatch = planJson.match(
                /```(?:json)?\s*([\s\S]*?)```/,
              );
              if (markdownMatch) {
                jsonString = markdownMatch[1];
              }

              // 2. Find the first '{' and last '}' to isolate the JSON object
              const firstBrace = jsonString.indexOf("{");
              const lastBrace = jsonString.lastIndexOf("}");

              if (
                firstBrace !== -1 &&
                lastBrace !== -1 &&
                lastBrace > firstBrace
              ) {
                const potentialJson = jsonString.substring(
                  firstBrace,
                  lastBrace + 1,
                );
                planData = JSON.parse(potentialJson);
              } else {
                throw new Error("No valid JSON object found in response");
              }
            } catch (e) {
              console.error("JSON Parse Error:", e);
              updateMessagesAssistant({
                uniqueId: `assistant-${currentUniqueId}`,
                content: `**Error parsing agent plan.**\n\nRaw output:\n${planJson}`,
              });
              resetUI();
              return;
            }

            // Check for completion
            if (!planData.plan || planData.plan.length === 0) {
              updateMessagesAssistant({
                uniqueId: `assistant-${currentUniqueId}`,
                content: `âœ… **Task Completed.**`,
              });
              messageArray.push({
                role: "assistant",
                content: "âœ… Task Completed.",
              });
              saveState();
              resetUI();
              return;
            }

            const step = planData.plan[0];
            if (step.type === "complete") {
              updateMessagesAssistant({
                uniqueId: `assistant-${currentUniqueId}`,
                content: `âœ… **Task Completed:** ${step.description}`,
              });
              messageArray.push({
                role: "assistant",
                content: `âœ… Task Completed: ${step.description}`,
              });
              saveState();
              resetUI();
              return;
            }

            // Render Plan
            let currentStepMarkdown = "";
            let planSteps = planData.plan;

            // If the FIRST step is complete, we are done.
            if (planSteps[0].type === "complete") {
              updateMessagesAssistant({
                uniqueId: `assistant-${currentUniqueId}`,
                content: `âœ… **Task Completed:** ${planSteps[0].description}`,
              });
              messageArray.push({
                role: "assistant",
                content: `âœ… Task Completed: ${planSteps[0].description}`,
              });
              saveState();
              resetUI();
              return;
            }

            // Build markdown for ALL steps
            planSteps.forEach((s, i) => {
              const stepNum = i + 1;
              let cleanDesc = s.description.replace(/^Step\s+\d+[:.]\s*/i, "");
              currentStepMarkdown += `**Step ${stepNum}:** ${cleanDesc}\n- [ ] ${cleanDesc}\n\n`;

              // Append to global plan for popup
              window.currentPlanMarkdown =
                (window.currentPlanMarkdown || "") +
                `- [ ] Step ${stepNum}: ${s.description}\n`;
            });

            updatePlanPopup(window.currentPlanMarkdown);
            updatePlanButtonTitle(window.currentPlanMarkdown);

            // Wrap in thinking block for auto-collapse
            const thinkingContent = `[thinking title="Executing Plan (${planSteps.length} Steps)"]\n${currentStepMarkdown}\n[/thinking]`;

            updateMessagesAssistant({
              uniqueId: `assistant-${currentUniqueId}`,
              content: thinkingContent,
            });

            // Execute Plan (pass ALL steps)
            const result = await executePlan(
              planSteps,
              currentUniqueId,
              userId,
              token,
              currentStepMarkdown,
              attachments,
              currentContext, // Pass accumulated context
              iteration,
            );

            // Update context with the result from executePlan
            currentContext = result.context;

            if (result.modifiedFiles) {
              result.modifiedFiles.forEach((f) => currentModifiedFiles.add(f));
            }

            // CRITICAL: Update history so the agent knows what it just did!
            // This prevents looping and "Step 1" hallucinations.
            const executedDescriptions = planSteps
              .map((s) => s.description)
              .join("\n- ");
            messageArray.push({
              role: "assistant",
              content: `[Plan Execution Completed]
Executed Steps:
- ${executedDescriptions}

Execution Result:
${result.summary || "Executed successfully."}`,
            });

            // Handle Auto-Fix / Replan
            if (result.autoFixTriggered) {
              // The recursive call has taken over. We stop this loop.
              return;
            }

            // FORCE STOP after full plan execution (User Requirement: 1 Plan only)
            // The agent has executed all steps in the single comprehensive plan.
            updateMessagesAssistant({
              uniqueId: `assistant-${currentUniqueId}`,
              content: `âœ… **All Tasks Completed.**\n\n${result.summary || ""}`,
            });
            messageArray.push({
              role: "assistant",
              content: `âœ… All Tasks Completed.\n\n${result.summary || ""}`,
            });
            saveState();
            resetUI();
            return;
          } catch (err) {
            if (err.name === "AbortError") {
              updateMessagesAssistant({
                uniqueId: `assistant-${currentUniqueId}`,
                content: "Stopped.",
              });
              resetUI();
              return;
            }
            console.error(err);
            updateMessagesAssistant({
              uniqueId: `assistant-${currentUniqueId}`,
              content: `Error: ${err.message}`,
            });
            resetUI();
            return;
          }
        }

        // Max iterations reached
        if (iteration >= MAX_ITERATIONS) {
          updateMessagesAssistant({
            uniqueId: `assistant-${currentUniqueId}`,
            content: `**Stopped: Max iterations (${MAX_ITERATIONS}) reached.**`,
          });
          messageArray.push({
            role: "assistant",
            content: "**Stopped: Max iterations reached.**",
          });
          saveState();
          resetUI();
        }
      }

      async function executePlan(
        plan,
        uniqueId,
        userId,
        token,
        initialMarkdown,
        attachments,
        existingContext = "", // Add existingContext parameter
        iteration = 1,
      ) {
        let context = existingContext; // Initialize with existing context
        let planMarkdown = initialMarkdown;
        // Ensure currentStepMarkdown is initialized
        let currentStepMarkdown = planMarkdown;
        let modifiedFiles = new Set();
        let autoFixTriggered = false;

        for (const step of plan) {
          if (!isLoading) {
            break;
          }
          // Update to In Progress in the chat bubble
          const inProgressRegex = new RegExp(
            `^\\s*-\\s*\\[\\s*\\]\\s*${step.description}`,
            "gm",
          );
          currentStepMarkdown = currentStepMarkdown.replace(
            inProgressRegex,
            `- [ðŸ”„] ${step.description}`,
          );
          updateMessagesAssistant({
            uniqueId: `assistant-${uniqueId}`,
            content: currentStepMarkdown,
          });

          // Update global plan status
          if (window.currentPlanMarkdown) {
            const globalStepRegex = new RegExp(
              `^\\s*-\\s*\\[\\s*\\]\\s*Step\\s+${iteration}:\\s*${step.description.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}`,
              "gm",
            );
            window.currentPlanMarkdown = window.currentPlanMarkdown.replace(
              globalStepRegex,
              `- [ðŸ”„] Step ${iteration}: ${step.description}`,
            );
            updatePlanPopup(window.currentPlanMarkdown);
            updatePlanButtonTitle(window.currentPlanMarkdown);
          }

          try {
            // --- PHASE 1: THINKING ---
            updateMessagesAssistant({
              uniqueId: `assistant-${uniqueId}`,
              content: currentStepMarkdown + `\n  > *Thinking...*`,
            });

            const thinkResponse = await fetch(
              "http://localhost:13100/api/agent/execute",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  userId,
                  token,
                  step,
                  context, // Pass the accumulated context
                  mode: "think",
                  attachments,
                }),
                signal: agentAbortController?.signal,
              },
            );

            const thinkReader = thinkResponse.body.getReader();
            const thinkDecoder = new TextDecoder();
            let thinkOutput = "";
            while (true) {
              const { value, done } = await thinkReader.read();
              if (done) break;
              thinkOutput += thinkDecoder.decode(value, { stream: true });
            }

            // Extract thought
            const thoughtMatch = thinkOutput.match(
              /\*\*Thought:\*\*([\s\S]*?)(?=\*\*Action:|$)/i,
            );
            const thought = thoughtMatch
              ? thoughtMatch[1].trim()
              : "Analyzing context...";

            // Update UI with thought
            currentStepMarkdown += `\n  > *Thought:* ${thought}\n`;
            updateMessagesAssistant({
              uniqueId: `assistant-${uniqueId}`,
              content: currentStepMarkdown,
            });

            // Check for [readFile]
            // Updated regex to be more flexible with quotes and spacing
            const readFileRegex = /\[readFile\]([\s\S]*?)\[\/readFile\]/;
            const readFileMatch = thinkOutput.match(readFileRegex);

            if (readFileMatch) {
              const fileBlock = readFileMatch[1];
              // Use non-global regex for matchAll or exec in loop
              const filePathsRegex = /\[file\s+path=["']([^"']+)["']\s*\]/g;
              let fileMatch;

              while ((fileMatch = filePathsRegex.exec(fileBlock)) !== null) {
                const filePath = fileMatch[1];

                // Visual feedback
                currentStepMarkdown += `\n  > *Reading file:* ${filePath}\n`;
                updateMessagesAssistant({
                  uniqueId: `assistant-${uniqueId}`,
                  content: currentStepMarkdown,
                });

                // Send readFile to extension with timeout
                try {
                  const fileContent = await new Promise((resolve, reject) => {
                    // Define handler first so we can remove it
                    let handleMessage;
                    let handleStop;

                    const timeout = setTimeout(() => {
                      window.removeEventListener("message", handleMessage);
                      window.removeEventListener("agent-stop", handleStop);
                      resolve(`Error: Timeout reading file ${filePath}`);
                    }, 15000); // 15 second timeout

                    handleStop = () => {
                      clearTimeout(timeout);
                      window.removeEventListener("message", handleMessage);
                      window.removeEventListener("agent-stop", handleStop);
                      const err = new Error("Aborted by user");
                      err.name = "AbortError";
                      reject(err);
                    };

                    handleMessage = (event) => {
                      if (
                        event.data.command === "readFileResult" &&
                        event.data.filePath === filePath
                      ) {
                        clearTimeout(timeout);
                        window.removeEventListener("message", handleMessage);
                        window.removeEventListener("agent-stop", handleStop);
                        resolve(event.data.content || event.data.error || "");
                      }
                    };
                    window.addEventListener("message", handleMessage);
                    window.addEventListener("agent-stop", handleStop);
                    vscode.postMessage({ type: "readFile", filePath });
                  });

                  const err = new Error("Aborted by user");
                  err.name = "AbortError";
                  if (!isLoading) throw err;

                  context += `\nFile Content (${filePath}):\n${fileContent}\n`;

                  // Visual feedback completion
                  currentStepMarkdown += `\n  > *Read complete.*\n`;
                  updateMessagesAssistant({
                    uniqueId: `assistant-${uniqueId}`,
                    content: currentStepMarkdown,
                  });
                } catch (e) {
                  context += `\nError reading file ${filePath}: ${e}\n`;
                  currentStepMarkdown += `\n  > *Error reading file:* ${e}\n`;
                  updateMessagesAssistant({
                    uniqueId: `assistant-${uniqueId}`,
                    content: currentStepMarkdown,
                  });
                }
              }
            }

            // Check for [searchFiles]
            const searchFilesRegex =
              /\[searchFiles\]([\s\S]*?)\[\/searchFiles\]/i;
            const searchFilesMatch = thinkOutput.match(searchFilesRegex);
            if (searchFilesMatch) {
              const query = searchFilesMatch[1].trim();
              currentStepMarkdown += `\n  > *Searching for:* \`${query}\`\n`;
              updateMessagesAssistant({
                uniqueId: `assistant-${uniqueId}`,
                content: currentStepMarkdown,
              });

              try {
                const searchResult = await new Promise((resolve, reject) => {
                  let handleMessage;
                  let handleStop;

                  const timeout = setTimeout(() => {
                    window.removeEventListener("message", handleMessage);
                    window.removeEventListener("agent-stop", handleStop);
                    resolve("Error: Timeout searching files.");
                  }, 60000);

                  handleStop = () => {
                    clearTimeout(timeout);
                    window.removeEventListener("message", handleMessage);
                    window.removeEventListener("agent-stop", handleStop);
                    const err = new Error("Aborted by user");
                    err.name = "AbortError";
                    reject(err);
                  };

                  handleMessage = (event) => {
                    if (event.data.command === "systemLog") {
                      currentStepMarkdown += `\n  > *${event.data.message}*`;
                      updateMessagesAssistant({
                        uniqueId: `assistant-${uniqueId}`,
                        content: currentStepMarkdown,
                      });
                    }
                    if (event.data.command === "searchResult") {
                      clearTimeout(timeout);
                      window.removeEventListener("message", handleMessage);
                      window.removeEventListener("agent-stop", handleStop);
                      resolve(
                        event.data.results || event.data.error || "No matches.",
                      );
                    }
                  };
                  window.addEventListener("message", handleMessage);
                  window.addEventListener("agent-stop", handleStop);
                  vscode.postMessage({ command: "search", query });
                });

                const err = new Error("Aborted by user");
                err.name = "AbortError";
                if (!isLoading) throw err;

                context += `\nSearch Results for "${query}":\n${searchResult}\n`;
                currentStepMarkdown += `\n  > *Search complete.*\n`;
                const displayResults =
                  searchResult.length > 500
                    ? searchResult.slice(0, 500) + "\n... (truncated)"
                    : searchResult;
                currentStepMarkdown += `\n\`\`\`\n${displayResults}\n\`\`\`\n`;
                updateMessagesAssistant({
                  uniqueId: `assistant-${uniqueId}`,
                  content: currentStepMarkdown,
                });
              } catch (e) {
                context += `\nError searching: ${e}\n`;
              }
            }

            // Check for [findFiles]
            const findFilesRegex = /\[findFiles\]([\s\S]*?)\[\/findFiles\]/i;
            const findFilesMatch = thinkOutput.match(findFilesRegex);
            if (findFilesMatch) {
              const pattern = findFilesMatch[1].trim();
              currentStepMarkdown += `\n  > *Finding files:* \`${pattern}\`\n`;
              updateMessagesAssistant({
                uniqueId: `assistant-${uniqueId}`,
                content: currentStepMarkdown,
              });

              let findResult = "";
              try {
                if (window.filePathCache && window.filePathCache.has(pattern)) {
                  findResult = window.filePathCache.get(pattern);
                  currentStepMarkdown += `\n  > *Found in cache.*\n`;
                  console.log(`[webview] Cache hit for pattern: ${pattern}`);
                } else {
                  findResult = await new Promise((resolve, reject) => {
                    let handleMessage;
                    let handleStop;

                    const timeout = setTimeout(() => {
                      window.removeEventListener("message", handleMessage);
                      window.removeEventListener("agent-stop", handleStop);
                      resolve("Error: Timeout finding files.");
                    }, 60000);

                    handleStop = () => {
                      clearTimeout(timeout);
                      window.removeEventListener("message", handleMessage);
                      window.removeEventListener("agent-stop", handleStop);
                      const err = new Error("Aborted by user");
                      err.name = "AbortError";
                      reject(err);
                    };

                    handleMessage = (event) => {
                      if (event.data.command === "systemLog") {
                        currentStepMarkdown += `\n  > *${event.data.message}*`;
                        updateMessagesAssistant({
                          uniqueId: `assistant-${uniqueId}`,
                          content: currentStepMarkdown,
                        });
                      }
                      if (event.data.command === "listFilesResult") {
                        clearTimeout(timeout);
                        window.removeEventListener("message", handleMessage);
                        window.removeEventListener("agent-stop", handleStop);
                        resolve(
                          event.data.files
                            ? event.data.files.join("\n")
                            : event.data.error || "No files found.",
                        );
                      }
                    };
                    window.addEventListener("message", handleMessage);
                    window.addEventListener("agent-stop", handleStop);
                    vscode.postMessage({ command: "listFiles", pattern });
                  });

                  // Cache the result
                  if (findResult && !findResult.startsWith("Error")) {
                    if (window.filePathCache) {
                      window.filePathCache.set(pattern, findResult);
                      saveState(); // Persist immediately
                    }
                  }
                }

                const err = new Error("Aborted by user");
                err.name = "AbortError";
                if (!isLoading) throw err;

                context += `\nFiles Found for "${pattern}":\n${findResult}\n`;
                currentStepMarkdown += `\n  > *Find complete.*\n`;
                const displayFiles =
                  findResult.length > 500
                    ? findResult.slice(0, 500) + "\n... (truncated)"
                    : findResult;
                currentStepMarkdown += `\n\`\`\`\n${displayFiles}\n\`\`\`\n`;
                updateMessagesAssistant({
                  uniqueId: `assistant-${uniqueId}`,
                  content: currentStepMarkdown,
                });
              } catch (e) {
                context += `\nError finding files: ${e}\n`;
              }
            }

            // Sync planMarkdown with currentStepMarkdown to include Think logs
            planMarkdown = currentStepMarkdown;

            // --- PHASE 2: EXECUTE ---
            if (planMarkdown.indexOf("> *Executing...*") === -1) {
              planMarkdown += `\n  > *Executing...*\n`;
              updateMessagesAssistant({
                uniqueId: `assistant-${uniqueId}`,
                content: planMarkdown,
              });
            }

            const response = await fetch(
              "http://localhost:13100/api/agent/execute",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  userId,
                  token,
                  step,
                  context,
                  mode: "execute",
                  attachments,
                }),
                signal: agentAbortController?.signal,
              },
            );

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let stepOutput = "";

            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              const chunk = decoder.decode(value, { stream: true });
              stepOutput += chunk;

              // Only update UI if we have a substantial chunk or it's been a while?
              // For now, let's assume stepOutput is raw text.
              // We want to replace the "Executing..." block or append to it.
              // But stepOutput grows.
              // Let's create a temporary variable for display.
              // We need to escape special markdown characters if we are dumping raw text?
              // The agent output usually contains markdown.

              // Strategy: Replace "Executing..." with "Executing...\n\n" + stepOutput
              // But planMarkdown already has "Executing...".

              const executingBlock = `\n  > *Executing...*\n`;
              // Update with streaming output
              updateMessagesAssistant({
                uniqueId: `assistant-${uniqueId}`,
                content: planMarkdown + executingBlock + `\n${stepOutput}`,
              });
            }

            // After execution, remove "Executing..." and append final output
            planMarkdown = planMarkdown.replace(`\n  > *Executing...*\n`, "");
            // But we want to KEEP the execution log in the assistant message for history!
            // Actually, usually we summarize. But for debugging, full log is better.
            // Let's format it nicely.
            planMarkdown += `\n> *Execution Output:*\n\`\`\`\n${stepOutput.slice(0, 1000)}${stepOutput.length > 1000 ? "..." : ""}\n\`\`\`\n`;

            updateMessagesAssistant({
              uniqueId: `assistant-${uniqueId}`,
              content: planMarkdown,
            });

            // Append output to context for next steps
            // CRITICAL: Ensure we capture the FULL output for the agent's context
            // Note: 'context' is updated below correctly combining previous context and stepOutput.
            // currentContext += ... NO, currentContext is not in scope here.

            // Also capture any file read/search results that happened in the "Think" phase
            // (They were added to 'context' local variable, but we need them in 'currentContext')
            // Wait, 'context' local variable was initialized from 'currentContext' at the start of loop?
            // No, in handleAgentWorkflow:
            //    let currentContext = "";
            //    ...
            //    const context = currentContext;
            // So 'context' is a local copy? No, strings are immutable.
            // We need to update 'currentContext' with whatever was added to 'context'.

            // Actually, we should just use 'currentContext' throughout.
            // But the code above used 'context'.
            // Let's synchronize them.
            // The code above did: context += ...
            // So we need to make sure those changes are reflected in currentContext for the NEXT iteration.

            // Calculate the diff or just append?
            // 'context' started as 'currentContext'.
            // So 'context' contains 'currentContext' + new stuff.

            // Only update currentContext if context has more content (it should)
            // But 'currentContext' is not defined in this scope!
            // 'context' is the local variable we are accumulating.

            /* 
            if (context.length > currentContext.length) {
              currentContext = context;
            } else {
              currentContext = context;
            }
            */

            // Also append the execution output to currentContext if it wasn't added to 'context' yet?
            // stepOutput is added to 'currentContext' above: currentContext += ...
            // But 'context' does NOT have stepOutput yet.
            // So if we set currentContext = context, we lose stepOutput!

            // Correct logic:
            // 1. 'context' has the Think phase results (read/search).
            // 2. 'stepOutput' has the Execute phase results.
            // 3. We want currentContext to have BOTH.
            // 4. 'existingContext' passed to this function is the BASE.
            // 5. 'context' variable in this function started as 'existingContext' and had Think results appended.

            // So:
            const newContext =
              context +
              `\nStep ${step.step} Execution Output:\n${stepOutput}\n`;

            // We need to return the FULL UPDATED context to the caller
            // But we also need to update the local 'context' variable for the next iteration of the loop
            // (even though executePlan loop usually only has 1 step now)
            context = newContext;

            // Update to Complete in the chat bubble
            const completeRegex = new RegExp(
              `^\\s*-\\s*\\[ðŸ”„\\]\\s*${step.description}`,
              "gm",
            );
            currentStepMarkdown = currentStepMarkdown.replace(
              completeRegex,
              `- [âœ…] ${step.description}`,
            );
            updateMessagesAssistant({
              uniqueId: `assistant-${uniqueId}`,
              content: currentStepMarkdown,
            });

            // Update global plan status to Complete
            if (window.currentPlanMarkdown) {
              const globalStepRegex = new RegExp(
                `^\\s*-\\s*\\[ðŸ”„\\]\\s*Step\\s+${iteration}:\\s*${step.description.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}`,
                "gm",
              );
              window.currentPlanMarkdown = window.currentPlanMarkdown.replace(
                globalStepRegex,
                `- [âœ…] Step ${iteration}: ${step.description}`,
              );
              updatePlanPopup(window.currentPlanMarkdown);
              updatePlanButtonTitle(window.currentPlanMarkdown);
            }

            // Process Actions
            if (stepOutput.includes("[REPLAN]")) {
              autoFixTriggered = true;
              const replanMatch =
                stepOutput.match(/\[REPLAN\]([\s\S]*?)\[\/REPLAN\]/i) ||
                stepOutput.match(/\[REPLAN\]([\s\S]*?)$/i);
              const replanReason = replanMatch
                ? replanMatch[1].trim()
                : "Replanning required.";

              const fixMessage = `The agent requested a REPLAN during Step ${step.step}.
Reason: ${replanReason}

**URGENT: ADJUST PLAN AND RESUME**
1. **ANALYZE**: Why was the replan requested? (e.g. file missing, context mismatch)
2. **NEW PLAN**: Create a NEW set of steps to achieve the *ORIGINAL REQUEST* given the new information.
3. **EXECUTE**: Start executing the new plan.

Original Request:
"""
${(typeof message === "string" ? message : JSON.stringify(message || "")).replace(/\`/g, "'")}
"""`;

              // Check if currentStepMarkdown is defined, if not, fallback to planMarkdown or empty string
              if (typeof currentStepMarkdown !== "undefined") {
                currentStepMarkdown += `\n> *âš ï¸ Plan Divergence. Replanning...*\n`;
                currentStepMarkdown += `\n> *Reason:* ${replanReason}\n`;
                updateMessagesAssistant({
                  uniqueId: `assistant-${uniqueId}`,
                  content: currentStepMarkdown,
                });
              } else {
                // Fallback if currentStepMarkdown is missing
                planMarkdown += `\n> *âš ï¸ Plan Divergence. Replanning...*\n`;
                planMarkdown += `\n> *Reason:* ${replanReason}\n`;
                updateMessagesAssistant({
                  uniqueId: `assistant-${uniqueId}`,
                  content: planMarkdown,
                });
              }

              await handleAgentWorkflow(
                fixMessage,
                Date.now() + Math.random(),
                attachments,
                true,
              );

              const errorRegex = new RegExp(
                `^\\s*-\\s*\\[ðŸ”„\\]\\s*(Step\\s+${step.step}:)`,
                "gm",
              );
              planMarkdown = planMarkdown.replace(errorRegex, `- [âŒ] $1`);
              planMarkdown += `\n  > *Step ${step.step} Cancelled (Replanning).*\n`;

              updateMessagesAssistant({
                uniqueId: `assistant-${uniqueId}`,
                content: planMarkdown,
              });

              break;
            }

            if (stepOutput.includes("[writeFile]")) {
              // Wait for writeFile to finish to avoid race conditions with subsequent readFiles
              await new Promise((resolve, reject) => {
                let handleMessage;
                let handleStop;

                const timeout = setTimeout(() => {
                  window.removeEventListener("message", handleMessage);
                  window.removeEventListener("agent-stop", handleStop);
                  resolve();
                }, 10000);

                handleStop = () => {
                  clearTimeout(timeout);
                  window.removeEventListener("message", handleMessage);
                  window.removeEventListener("agent-stop", handleStop);
                  const err = new Error("Aborted by user");
                  err.name = "AbortError";
                  reject(err);
                };

                handleMessage = (event) => {
                  if (event.data.command === "writeFileFinished") {
                    clearTimeout(timeout);
                    window.removeEventListener("message", handleMessage);
                    window.removeEventListener("agent-stop", handleStop);
                    resolve();
                  }
                };
                window.addEventListener("message", handleMessage);
                window.addEventListener("agent-stop", handleStop);

                // Send the message inside the promise setup to ensure we don't miss the response
                // (though unlikely with JS event loop)
                vscode.postMessage({
                  type: "writeFile",
                  assistantMessage: stepOutput,
                });
              });

              const fileRegex = /\[file name="([^"]+)"\]/g;
              let match;
              while ((match = fileRegex.exec(stepOutput)) !== null) {
                const fName = match[1];
                // Hide memory.md from modified files list in chat
                if (!fName.endsWith("memory.md")) {
                  modifiedFiles.add(fName);
                }
              }

              // Extract and save file content for Open Diff button
              const fileContentRegex =
                /\[file name="([^"]+)"\]([\s\S]*?)\[\/file\]/g;
              let contentMatch;

              // Handle potential overlapping matches or multiple files in one block
              // We need to be careful with greedy matching in [\s\S]*? if there are multiple files
              // A safer approach might be to split by [file or just rely on the regex if well-formed

              // Let's try to match all occurrences
              const allContent = stepOutput;
              let lastIndex = 0;

              while (
                (contentMatch = fileContentRegex.exec(allContent)) !== null
              ) {
                const fPath = contentMatch[1];
                let fContent = contentMatch[2];

                // FIX: Strip markdown code blocks if the agent mistakenly included them inside [file] tags
                // This handles cases where the agent wraps code in ```typescript ... ``` inside [file] tags
                const trimmed = fContent.trim();
                if (trimmed.startsWith("```") && trimmed.endsWith("```")) {
                  // Remove the first ```... line and the last ``` line to get raw code
                  fContent = trimmed
                    .replace(/^```[^\n]*\n/, "")
                    .replace(/\n```$/, "");
                }

                window.fileContentMap.set(fPath, fContent);
                console.log(
                  `[webview] Stored content for ${fPath} (length: ${fContent.length})`,
                );

                // CRITICAL: Update context so the planner knows the file state
                context += `\nFile Content (${fPath}):\n${fContent}\n`;
              }
            }
            if (stepOutput.includes("[command]")) {
              const commandMatch = stepOutput.match(
                /\[command\]([\s\S]*?)\[\/command\]/,
              );
              if (commandMatch) {
                const command = commandMatch[1].trim();

                // Add a "Terminal Output" block
                let terminalOutput = "";
                // Remove the "Executing..." visual if it's still there (handled above by replace)

                // Show that we are running the command
                planMarkdown += `\n  > *Running command:* \`${command}\`\n`;
                planMarkdown += `\n**Terminal Output:**\n\`\`\`bash\n`;

                updateMessagesAssistant({
                  uniqueId: `assistant-${uniqueId}`,
                  content: planMarkdown + "\n\`\`\`",
                });

                // Request execution and wait for completion
                const exitCode = await new Promise((resolve, reject) => {
                  let handleMessage;
                  let handleStop;

                  handleStop = () => {
                    window.removeEventListener("message", handleMessage);
                    window.removeEventListener("agent-stop", handleStop);
                    const err = new Error("Aborted by user");
                    err.name = "AbortError";
                    reject(err);
                  };

                  handleMessage = (event) => {
                    if (event.data.command === "commandOutput") {
                      terminalOutput += event.data.output;
                      // Update UI
                      updateMessagesAssistant({
                        uniqueId: `assistant-${uniqueId}`,
                        content: planMarkdown + terminalOutput + "\n\`\`\`",
                      });
                    }
                    if (event.data.command === "commandFinished") {
                      window.removeEventListener("message", handleMessage);
                      window.removeEventListener("agent-stop", handleStop);

                      // Add note about external terminal if we didn't capture much output
                      if (terminalOutput.trim().length === 0) {
                        terminalOutput += "(See VS Code Terminal for output)";
                      }

                      // Use output from event if available (from child_process workaround), otherwise fallback to captured terminal output
                      if (event.data.output) {
                        terminalOutput = event.data.output;
                      }

                      if (event.data.exitCode !== 0) {
                        console.error(
                          `Command failed with exit code ${event.data.exitCode}`,
                        );
                        terminalOutput += `\n\n[Process exited with code ${event.data.exitCode}]`;
                      } else {
                        terminalOutput += `\n\n[Process completed successfully]`;
                      }

                      // Safety truncation for large outputs to prevent context overflow
                      if (terminalOutput.length > 500000) {
                        terminalOutput =
                          terminalOutput.slice(0, 500000) +
                          "\n... [Output truncated (too large for context). Please refine command with exclusions.]";
                      }

                      // Final update with full output
                      updateMessagesAssistant({
                        uniqueId: `assistant-${uniqueId}`,
                        content: planMarkdown + terminalOutput + "\n\`\`\`",
                      });

                      // CRITICAL: Update context so the planner knows the command result
                      context += `\nCommand Output for "${command}":\n${terminalOutput}\n`;

                      resolve(event.data.exitCode);
                    }
                    // Handle commandStopped event from SidebarProvider
                    if (event.data.command === "commandStopped") {
                      window.removeEventListener("message", handleMessage);
                      window.removeEventListener("agent-stop", handleStop);
                      terminalOutput += `\n\n[Process stopped by user]`;

                      updateMessagesAssistant({
                        uniqueId: `assistant-${uniqueId}`,
                        content: planMarkdown + terminalOutput + "\n\`\`\`",
                      });

                      const err = new Error("Aborted by user");
                      err.name = "AbortError";
                      reject(err);
                    }
                  };
                  window.addEventListener("message", handleMessage);
                  window.addEventListener("agent-stop", handleStop);
                  vscode.postMessage({ type: "executeCommand", command });
                });

                planMarkdown += terminalOutput + "\n\`\`\`\n";

                // Auto-Terminal-Fixing Logic
                if (exitCode !== 0) {
                  autoFixTriggered = true;
                  const fixMessage = `The terminal command failed with exit code ${exitCode}.
      Command: ${command}
      Output:
      \`\`\`
      ${terminalOutput}
      \`\`\`
      
      **URGENT: FIX AND RESUME**
      1. **DIAGNOSE**: Why did it fail? (Missing dependency? Wrong path? Syntax error?)
         - **IF MISSING PACKAGE**: Run \`npm install <package>\` or \`pip install <package>\` IMMEDIATELY. Do not search for the package file.
      2. **FIX**: Apply the fix immediately.
      3. **RESUME**: You MUST complete the *ORIGINAL REQUEST* after fixing.
         - Do NOT stop after fixing.
         - Do NOT just say "Fixed".
         - **GENERATE A COMPLETE PLAN TO FINISH THE ENTIRE ORIGINAL TASK.**
      
      Original Request:
      """
      ${(typeof message === "string" ? message : JSON.stringify(message || "")).replace(/\`/g, "'")}
      """`;

                  planMarkdown += `\n> *âš ï¸ Command failed. Delegating to Auto-Fix Agent...*\n`;
                  updateMessagesAssistant({
                    uniqueId: `assistant-${uniqueId}`,
                    content: planMarkdown,
                  });

                  // Recursively call agent to fix
                  await handleAgentWorkflow(
                    fixMessage,
                    Date.now() + Math.random(),
                    attachments,
                    true, // isRetry/isFix
                  );

                  const errorRegex = new RegExp(
                    `^\\s*-\\s*\\[ðŸ”„\\]\\s*(Step\\s+${step.step}:)`,
                    "gm",
                  );
                  planMarkdown = planMarkdown.replace(errorRegex, `- [âŒ] $1`);
                  planMarkdown += `\n  > *Step ${step.step} Failed. Auto-Fix workflow initiated above.*\n`;

                  updateMessagesAssistant({
                    uniqueId: `assistant-${uniqueId}`,
                    content: planMarkdown,
                  });

                  // Stop this plan (since we delegated to a new agent instance)
                  break;
                }
              }
            }
            // After loop
            if (autoFixTriggered) break;

            // Update to Done - use more flexible regex
            const doneRegex = new RegExp(
              `^\\s*-\\s*\\[ðŸ”„\\]\\s*(Step\\s+${step.step}:)`,
              "gm",
            );
            planMarkdown = planMarkdown.replace(doneRegex, `- [âœ…] $1`);
            updatePlanPopup(planMarkdown);

            // Extract reasoning
            const reasoningMatch = stepOutput.match(
              /\*\*Reasoning:\*\*([\s\S]*?)(?=\*\*Action:|$)/,
            );
            const reasoning = reasoningMatch
              ? reasoningMatch[1].trim()
              : "Executed.";

            planMarkdown += `\n  > *Step ${step.step}:* ${reasoning}\n`;
            updateMessagesAssistant({
              uniqueId: `assistant-${uniqueId}`,
              content: planMarkdown,
            });
            updatePlanPopup(planMarkdown);

            // Re-inject modified files diff buttons at the end of EACH step to ensure they are available
            // This is optional but helps if user wants to see diffs incrementally
          } catch (err) {
            if (err.name === "AbortError") {
              updateMessagesAssistant({
                uniqueId: `assistant-${uniqueId}`,
                content: planMarkdown + `\n  > *Stopped by user.*`,
              });
              throw err;
            }
            const errorRegex = new RegExp(
              `^\\s*-\\s*\\[ðŸ”„\\]\\s*(Step\\s+${step.step}:)`,
              "gm",
            );
            planMarkdown = planMarkdown.replace(errorRegex, `- [âŒ] $1`);
            planMarkdown += `\n  > *Step ${step.step} Error:* ${err.message}\n`;
            updateMessagesAssistant({
              uniqueId: `assistant-${uniqueId}`,
              content: planMarkdown,
            });
            updatePlanPopup(planMarkdown);
            updatePlanButtonTitle(planMarkdown);
            break; // Stop execution on error
          }
        }

        if (!autoFixTriggered) {
          // planMarkdown += `\n\n**All steps completed.**`; // Removed as per user request to be less intrusive

          // --- SUMMARY GENERATION ---
          try {
            updateMessagesAssistant({
              uniqueId: `assistant-${uniqueId}`,
              content: planMarkdown + `\n\n> *Generating summary...*`,
            });

            const summaryResponse = await fetch(
              "http://localhost:13100/api/agent/summary",
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  userId,
                  token,
                  context,
                  originalRequest: message, // We need the original request to frame the summary
                }),
                signal: agentAbortController?.signal,
              },
            );

            if (summaryResponse.ok) {
              const summaryReader = summaryResponse.body.getReader();
              const summaryDecoder = new TextDecoder();
              let summaryText = "";
              while (true) {
                const { value, done } = await summaryReader.read();
                if (done) break;
                summaryText += summaryDecoder.decode(value, { stream: true });
              }

              if (summaryText) {
                planMarkdown += `\n\n---\n\n### ðŸ“ Session Summary\n${summaryText}`;
              }
            }
          } catch (e) {
            console.error("Failed to generate summary:", e);
            // Fail silently, don't block the completion
          }
        }

        // Move Modified Files section to the end (after summary)
        if (modifiedFiles.size > 0) {
          planMarkdown += `\n\n**Modified Files:**\n`;
          const filesList = Array.from(modifiedFiles).join(",");
          // Add Open Diff buttons for each file
          modifiedFiles.forEach((file) => {
            planMarkdown += `\n[openDiff path="${file}"]`;
          });
          // Add Keep All Files button at the end
          planMarkdown += `\n\n[keepAllFiles files="${filesList}"]\n`;
        }

        updateMessagesAssistant({
          uniqueId: `assistant-${uniqueId}`,
          content: planMarkdown,
        });
        updatePlanPopup(planMarkdown);
        updatePlanButtonTitle(planMarkdown);

        // Finalize
        messageArray.push({ role: "assistant", content: planMarkdown });
        saveState();

        return {
          context,
          modifiedFiles,
          autoFixTriggered,
          summary: planMarkdown,
        };
      }

      // Plan-related functions
      function togglePlanPopup() {
        const container = document.getElementById("planStatusContainer");
        const planPopup = document.getElementById("planPopup");

        // Toggle inline container
        if (container) {
          if (container.classList.contains("hidden")) {
            container.classList.remove("hidden");
            container.scrollTop = container.scrollHeight;
          } else {
            container.classList.add("hidden");
          }
        }

        // Hide old popup if it exists
        if (planPopup) {
          planPopup.style.display = "none";
        }
      }

      // Test function to manually trigger plan button visibility
      function testPlanButton() {
        console.log("Testing plan button...");
        const planButton = document.getElementById("planButton");
        if (planButton) {
          planButton.style.display = "inline-block";
          const testPlanMarkdown = `- [ ] Step 1: Initialize project
            - [âœ…] Step 2: Setup configuration
            - [âœ…] Step 3: Create components
            - [ ] Step 4: Add styling
            - [ ] Step 5: Test application`;

          // Debug the counting logic
          console.log("Test markdown:", testPlanMarkdown);
          const totalTasks = (
            testPlanMarkdown.match(/^\s*-\s*\[[ xðŸ”„âœ…âŒ]\]\s*Step\s+\d+:/gm) ||
            []
          ).length;
          const completedTasks = (
            testPlanMarkdown.match(/^\s*-\s*\[âœ…\]\s*Step\s+\d+:/gm) || []
          ).length;
          console.log("Debug - Total tasks:", totalTasks);
          console.log("Debug - Completed tasks:", completedTasks);
          console.log(
            "Debug - All matches:",
            testPlanMarkdown.match(/^\s*-\s*\[[\s\w]*\]\s*Step\s+\d+:/gm),
          );
          console.log(
            "Debug - Completed matches:",
            testPlanMarkdown.match(/^\s*-\s*\[âœ…\]\s*Step\s+\d+:/gm),
          );

          updatePlanButtonTitle(testPlanMarkdown);
          updatePlanPopup(testPlanMarkdown);
          console.log("Plan button should be visible with test data");
        }
      }

      function testTaskProgression() {
        console.log("Testing task progression...");

        // Test with a realistic progression
        let testMarkdown = `- [ ] Step 1: Initialize project
            - [ ] Step 2: Setup configuration
            - [ ] Step 3: Create components`;

        console.log("=== Initial State ===");
        console.log("Markdown:", testMarkdown);
        updatePlanButtonTitle(testMarkdown);
        updatePlanPopup(testMarkdown);

        // Mark first task as in progress
        const inProgressRegex = new RegExp(
          `^\\s*-\s*\\[\\s*\\]\\s*(Step\\s+1:)`,
          "gm",
        );
        testMarkdown = testMarkdown.replace(inProgressRegex, `- [ðŸ”„] $1`);

        console.log("=== After marking Step 1 as in progress ===");
        console.log("Markdown:", testMarkdown);
        updatePlanButtonTitle(testMarkdown);
        updatePlanPopup(testMarkdown);

        // Complete first task
        const doneRegex = new RegExp(`^\\s*-\s*\\[ðŸ”„\\]\\s*(Step\\s+1:)`, "gm");
        testMarkdown = testMarkdown.replace(doneRegex, `- [âœ…] $1`);

        console.log("=== After completing Step 1 ===");
        console.log("Markdown:", testMarkdown);
        updatePlanButtonTitle(testMarkdown);
        updatePlanPopup(testMarkdown);

        console.log("=== Test completed ===");
      }

      function showPlanPopup() {
        const planPopup = document.getElementById("planPopup");
        const planButton = document.getElementById("planButton");
        const messageInputContainer = document.getElementById(
          "messageInputContainer",
        );
        console.log("showPlanPopup called");
        console.log("planPopup:", planPopup);
        console.log("planButton:", planButton);
        console.log("messageInputContainer:", messageInputContainer);
        if (planPopup && planButton && messageInputContainer) {
          // First, make popup visible to get dimensions
          planPopup.style.display = "block";

          // Position popup above the message input container
          const rect = messageInputContainer.getBoundingClientRect();
          console.log("Container rect:", rect);
          console.log("Popup offsetHeight:", planPopup.offsetHeight);

          // Calculate position - ensure it's visible on screen
          let top = rect.top - planPopup.offsetHeight - 5;
          let left = rect.left;

          // Ensure popup doesn't go off the top of the screen
          if (top < 10) {
            top = 10;
          }

          // Ensure popup doesn't go off the left side
          if (left < 10) {
            left = 10;
          }

          planPopup.style.top = top + "px";
          planPopup.style.left = left + "px";
          console.log("Popup positioned at:", top, left);
          console.log("Popup should be visible now");
        } else {
          // Fallback: just show the popup with default positioning
          console.log(
            "Fallback positioning - showing popup with default position",
          );
          planPopup.style.top = "50px";
          planPopup.style.left = "50px";
          planPopup.style.display = "block";
        }
      }

      function hidePlanPopup() {
        const planPopup = document.getElementById("planPopup");
        if (planPopup) {
          planPopup.style.display = "none";
        }
      }

      function updatePlanButtonTitle(planMarkdown) {
        console.log("updatePlanButtonTitle called");
        const planButton = document.getElementById("planButton");
        const planStatusContent = document.getElementById("planStatusContent");

        if (!planButton) return;

        // improved regex to match "- [ ] Step 1: ..." or "- [x] Step 1: ..."
        const taskRegex = /^\s*-\s*\[([ xðŸ”„âœ…âŒ])\]\s*(Step\s+\d+.*)$/gm;
        let match;
        let totalTasks = 0;
        let completedTasks = 0;
        let taskHtml = "";

        while ((match = taskRegex.exec(planMarkdown)) !== null) {
          totalTasks++;
          const statusChar = match[1]; // ' ', 'x', 'ðŸ”„', 'âœ…', 'âŒ'
          const taskText = match[2];

          let icon = "â—»";
          let color = "text-gray-400";

          if (statusChar === "âœ…" || statusChar === "x") {
            completedTasks++;
            icon = "âœ…";
            color = "text-green-500";
          } else if (statusChar === "ðŸ”„") {
            icon = "ðŸ”„";
            color = "text-yellow-500";
          } else if (statusChar === "âŒ") {
            icon = "âŒ";
            color = "text-red-500";
          }

          taskHtml += `<div class="flex items-start gap-2 py-1 ${color}">
            <span>${icon}</span>
            <span class="flex-1">${taskText}</span>
          </div>`;
        }

        if (totalTasks > 0) {
          const progressText = `${completedTasks}/${totalTasks} Tasks done`;
          planButton.innerHTML = `ðŸ“‹ ${progressText}`;
          planButton.title = `Plan: ${progressText} completed`;
          planButton.style.display = "flex"; // Make sure it's visible!

          // Update the container above input
          if (planStatusContent) {
            planStatusContent.innerHTML = taskHtml;
          }
        } else {
          planButton.style.display = "none";
        }
      }

      function updatePlanPopup(planMarkdown) {
        // Ensure button and inline status are also updated
        updatePlanButtonTitle(planMarkdown);

        const planContent = document.getElementById("planContent");
        if (planContent) {
          // Extract only the task list without thoughts or other content
          const taskLines = planMarkdown
            .split("\n")
            .filter(
              (line) =>
                line.includes("Step ") &&
                (line.includes("[ ]") ||
                  line.includes("ðŸ”„") ||
                  line.includes("âœ…") ||
                  line.includes("âŒ")),
            );

          console.log("updatePlanPopup - Raw planMarkdown:", planMarkdown);
          console.log("updatePlanPopup - Filtered taskLines:", taskLines);

          let html = '<div style="font-size: 0.875rem;">';
          taskLines.forEach((line) => {
            if (line.includes("[ ] Step")) {
              html += `<div style="display: flex; align-items: center; padding: 4px 8px; cursor: pointer;" onmouseover="this.style.backgroundColor='#30363d'" onmouseout="this.style.backgroundColor='transparent'"><span style="color: #8b949e; margin-right: 8px;">â—»</span><span style="color: #c9d1d9;">${line.replace("- [ ] Step ", "")}</span></div>`;
            } else if (line.includes("[ðŸ”„] Step")) {
              html += `<div style="display: flex; align-items: center; padding: 4px 8px; cursor: pointer;" onmouseover="this.style.backgroundColor='#30363d'" onmouseout="this.style.backgroundColor='transparent'"><span style="color: #d29922; margin-right: 8px;">ðŸ”„</span><span style="color: #d29922;">${line.replace("- [ðŸ”„] Step ", "")}</span></div>`;
            } else if (line.includes("[âœ…] Step")) {
              html += `<div style="display: flex; align-items: center; padding: 4px 8px; cursor: pointer;" onmouseover="this.style.backgroundColor='#30363d'" onmouseout="this.style.backgroundColor='transparent'"><span style="color: #3fb950; margin-right: 8px;">âœ…</span><span style="color: #3fb950;">${line.replace("- [âœ…] Step ", "")}</span></div>`;
            } else if (line.includes("[âŒ] Step")) {
              html += `<div style="display: flex; align-items: center; padding: 4px 8px; cursor: pointer;" onmouseover="this.style.backgroundColor='#30363d'" onmouseout="this.style.backgroundColor='transparent'"><span style="color: #f85149; margin-right: 8px;">âŒ</span><span style="color: #f85149;">${line.replace("- [âŒ] Step ", "")}</span></div>`;
            }
          });
          html += "</div>";

          planContent.innerHTML = html;
        }
      }

      function resetUI() {
        const loader = document.getElementById("loader");
        const sendBtn = document.getElementById("button-send");
        const stopBtn = document.getElementById("button-stop");
        const newChatButton = document.getElementById("newChatButton");
        const historyButton = document.getElementById("historyButton");

        loader.classList.add("hidden");
        sendBtn.classList.remove("hidden");
        stopBtn.classList.add("hidden");

        if (newChatButton) newChatButton.disabled = false;
        if (historyButton) historyButton.disabled = false;
        document.getElementById("generating").innerHTML = "";
        isLoading = false;
        document.getElementById("messageInput").disabled = false;
        document.getElementById("messageInput").value = "";
        document.getElementById("messageInput").focus();
      }

      function showLoginForm() {
        const logo = document.getElementById("logo");
        if (logo) logo.style.display = "none";

        const headerControls = document.getElementById("header-controls");
        if (headerControls) headerControls.style.display = "none";

        const messageInputContainer = document.getElementById(
          "messageInputContainer",
        );
        if (messageInputContainer) messageInputContainer.style.display = "none";

        const content = document.getElementById("content");
        content.innerHTML = `
                        <div class="login-wrapper">
                            <div class="login-container">
                                <img src="%LOGO_PATH%" alt="Logo" class="login-logo">
                                <form id="loginForm" action="#" method="post">
                                    <input type="text" name="email" placeholder="Enter username" required />
                                    <button type="submit">Login âžœ</button>
                                </form>
                            </div>
                        </div>
                    `;

        const form = document.getElementById("loginForm");
        form.addEventListener("submit", login);
      }
      var formEmail = "";
      async function login(event) {
        event.preventDefault(); // Mencegah form dari submit default
        formEmail = event.target.email.value;

        const messageDiv = document.getElementById("message");
        const loginForm = document.getElementById("loginForm");

        try {
          // Send a message to the extension to find files

          if (isLoading) return;
          loginForm.innerHTML = `
                                    <input type="text" name="email" placeholder="Enter username" value="${formEmail}" required />
                                    <button type="submit" disabled>
                                        <svg class="loader-button" viewBox="0 0 24 24" width="16" height="16"> <!-- Adjust width and height -->
                                            <circle class="path" cx="12" cy="12" r="10" fill="none" stroke-width="3" /> <!-- Adjust stroke width if necessary -->
                                        </svg>
                                    </button>
                                `;
          isLoading = true;
          console.log("findFiles");
          vscode.postMessage({ type: "findFiles", email: formEmail });
        } catch (error) {
          messageDiv.textContent = "Email atau password salah.";
          messageDiv.className = "message error";
          isLoading = false;
          loginForm.innerHTML = `
                                        <input type="text" name="email" placeholder="Enter username" value="${email}" required />
                                        <button type="submit">âžœ]</button>
                                    `;
        }
      }

      async function loginAPI(workspacesParam, tokenParam) {
        const messageDiv = document.getElementById("message");
        const loginForm = document.getElementById("loginForm");
        console.log("tokenParam", tokenParam);
        try {
          // Send a message to the extension to find files

          loginForm.innerHTML = `
                                    <input type="text" name="email" placeholder="Enter username" value="${formEmail}" required />
                                    <button type="submit" disabled>
                                        <svg class="loader-button" viewBox="0 0 24 24" width="16" height="16"> <!-- Adjust width and height -->
                                            <circle class="path" cx="12" cy="12" r="10" fill="none" stroke-width="3" /> <!-- Adjust stroke width if necessary -->
                                        </svg>
                                    </button>
                                `;

          const response = await fetch("http://localhost:13100/api/login", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              email: formEmail,
              token: tokenParam,
            }),
          });

          if (!response.ok) {
            console.log("login gagal");
            messageDiv.textContent = "Email tidak valid.";
            messageDiv.className = "message error";
            isLoading = false;
            loginForm.innerHTML = `
                                        <input type="text" name="email" placeholder="Enter username" value="${formEmail}" required />
                                        <button type="submit">âžœ]</button>
                                    `;
            throw new Error("Login gagal");
          }

          console.log("login berhasil");
          const allCodeStorageKey = "allCodeStorage";
          const codingStorageKey = "codingStorage";
          localStorage.removeItem(allCodeStorageKey);
          localStorage.removeItem(codingStorageKey);

          const data = await response.json();
          localStorage.setItem("token", tokenParam);
          localStorage.setItem("userId", data.userId);
          vscode.postMessage({ type: "saveToken", tokenParam });

          messageDiv.textContent = "Login berhasil!";
          messageDiv.className = "message success";
          isLoading = false;
          setTimeout(() => {
            updateWorkspaces();
            loginForm.innerHTML = `
                                        <input type="text" name="email" placeholder="Enter username" value="${formEmail}" required />
                                        <button type="submit">âžœ]</button>
                                    `;
          }, 3000);

          messageDiv.textContent = "";

          const headerControls = document.getElementById("header-controls");
          if (headerControls) headerControls.style.display = "flex";

          const logo = document.getElementById("logo");
          if (logo) logo.style.display = "flex";

          const btnWorkspace = document.getElementById("button-workspace");
          if (btnWorkspace) btnWorkspace.style.display = "block";

          // Fetch and display chat history
          fetchHistory();
        } catch (error) {
          messageDiv.textContent = "Login Error.";
          messageDiv.className = "message error";
          isLoading = false;
          loginForm.innerHTML = `
                                        <input type="text" name="email" placeholder="Enter username" value="${formEmail}" required />
                                        <button type="submit">âžœ]</button>
                                    `;
        }
      }

      async function updateWorkspaces(silent = false) {
        if (isLoading && !silent && !pendingMessage) return;
        if (!silent) isLoading = true;

        const btnWorkspace = document.getElementById("button-workspace");
        btnWorkspace.innerHTML = `
                                <svg class="loader-button" viewBox="0 0 24 24" width="16" height="16"> <!-- Adjust width and height -->
                                    <circle class="path" cx="12" cy="12" r="10" fill="none" stroke-width="3" /> <!-- Adjust stroke width if necessary -->
                                </svg>
                            `;
        vscode.postMessage({ type: "updateWorkspaces", silent });
      }

      async function updateWorkspacesAPI(workspacesParam) {
        try {
          // Send a message to the extension to find files

          const tokenData = localStorage.getItem("token");

          const response = await fetch("http://localhost:13100/api/workspace", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              token: tokenData,
              workspaces: workspacesParam,
            }),
          });

          if (!response.ok) {
            console.log("update workspaces gagal");
            isLoading = false;
          }
          console.log("update workspaces berhasil");
          const btnWorkspace = document.getElementById("button-workspace");
          btnWorkspace.style.display = "block";
          btnWorkspace.innerHTML = `Teach AI Current Code ðŸ”„`;
          btnWorkspace.addEventListener("click", updateWorkspaces);
          isLoading = false;

          if (pendingMessage) {
            const msg = pendingMessage;
            const atts = pendingAttachments;
            pendingMessage = null;
            console.log("Retrying pending message...");
            if (atts) {
              attachments = atts;
              pendingAttachments = null;
            }
            sendMessageToApi(msg, true);
          }
        } catch (error) {
          console.log("update workspaces gagal");
          isLoading = false;
        }
      }

      async function cancelUpdateWorkspaces() {
        isLoading = false;
        const btnWorkspace = document.getElementById("button-workspace");
        btnWorkspace.style.display = "block";
        btnWorkspace.innerHTML = `Teach AI Current Code ðŸ”„`;
        btnWorkspace.addEventListener("click", updateWorkspaces);
      }

      async function fetchHistory() {
        // Request history from extension
        vscode.postMessage({ type: "getHistory" });

        const logo = document.getElementById("logo");
        logo.style.display = "block";
        const token = localStorage.getItem("token");
        vscode.postMessage({ type: "saveToken", token });
        const userId = localStorage.getItem("userId");

        // Restore file content map from global state if possible?
        // Actually, we should rebuild it from the HTML or messages.
        // Let's rely on loadMessages to rebuild it if we fetch from API.
        // If we restore from persistedState, we might miss it if we don't save the map.

        if (persistedState.messagesHTML) {
          document.getElementById("content").innerHTML =
            persistedState.messagesHTML;
          document.getElementById("messageInput").value =
            persistedState.input ?? "";

          // Rebuild map from the restored HTML content (less reliable) or persisted messages
          if (persistedState.messages) {
            window.fileContentMap.clear();
            persistedState.messages.forEach((msg) => {
              if (msg.role === "assistant") {
                const fileContentRegex =
                  /\[file name="([^"]+)"\]([\s\S]*?)\[\/file\]/g;
                let contentMatch;
                while (
                  (contentMatch = fileContentRegex.exec(msg.content)) !== null
                ) {
                  const fPath = contentMatch[1];
                  const fContent = contentMatch[2];
                  window.fileContentMap.set(fPath, fContent);
                }
              }
            });
          }

          // Show the message input container
          const messageInputContainer = document.getElementById(
            "messageInputContainer",
          );
          messageInputContainer.style.display = "block";
          // Scroll to the bottom of the content
          var content = document.getElementById("content");
          content.scrollTop = content.scrollHeight;
          // focus the message input
          const messageInput = document.getElementById("messageInput");
          messageInput.focus();
          return;
        }
        try {
          const response = await fetch(
            `http://localhost:13100/api/history/?token=${token}&userId=${userId}`,
            {
              method: "GET",
              headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
                "Content-Type": "application/json",
              },
            },
          );

          if (!response.ok) {
            throw new Error("Failed to fetch history");
          }

          const historyData = await response.json();
          console.log(historyData);
          loadMessages(historyData);
          messageArray = historyData.messages;
          saveState();
        } catch (error) {
          console.error("Error fetching history:", error);
          document.getElementById("message").textContent =
            "Gagal mengambil riwayat chat.";
          document.getElementById("message").className = "message error";

          // Perform logout
          logout();
        }
      }

      async function checkUrlExists(url) {
        try {
          const response = await fetch(url, { method: "HEAD" });
          return response.ok; // Return true if the response is OK (status 200)
        } catch (error) {
          console.error("Error checking URL:", error);
          return false; // Return false if there was an error
        }
      }

      async function loadMessages(messages) {
        const content = document.getElementById("content");
        content.innerHTML = "Loading...";
        try {
          displayMessages(messages.messages);

          // Re-populate fileContentMap from message history
          window.fileContentMap.clear();
          messages.messages.forEach((msg) => {
            if (msg.role === "assistant") {
              const fileContentRegex =
                /\[file name="([^"]+)"\]([\s\S]*?)\[\/file\]/g;
              let contentMatch;
              while (
                (contentMatch = fileContentRegex.exec(msg.content)) !== null
              ) {
                const fPath = contentMatch[1];
                const fContent = contentMatch[2];
                window.fileContentMap.set(fPath, fContent);
                console.log(`[webview] Restored content for ${fPath}`);
              }
            }
          });

          // Show the message input container
          const messageInputContainer = document.getElementById(
            "messageInputContainer",
          );
          messageInputContainer.style.display = "block";

          // Scroll to the bottom of the content
          content.scrollTop = content.scrollHeight;
          const messageInput = document.getElementById("messageInput");
          messageInput.focus();
        } catch (error) {
          console.error("Error fetching messages:", error);
          content.innerHTML = "Failed to load messages.";
        }
      }

      var isAudioPlay = true;

      function displayMessages(messages) {
        const content = document.getElementById("content");
        content.innerHTML = "";

        messages.forEach((msg) => {
          if (msg.role !== "system") {
            displayMessagesAssistant(msg);
          }
        });

        const messageInput = document.getElementById("messageInput");
        if (messageInput) messageInput.focus();
      }

      function displayMessagesAssistant(msg) {
        const content = document.getElementById("content");
        let chatContainer = document.getElementById("chat-container");
        if (!chatContainer) {
          chatContainer = document.createElement("div");
          chatContainer.id = "chat-container";
          chatContainer.className = "custom-scrollbar";
          content.innerHTML = "";
          content.appendChild(chatContainer);
        }

        const messageDiv = document.createElement("div");
        messageDiv.className = `message-container ${msg.role === "user" ? "user" : "agent"}`;

        const messageContent = document.createElement("div");
        messageContent.id = msg.uniqueId;
        messageContent.className = `message-bubble ${msg.role === "user" ? "user-message" : "agent-message"}`;
        messageContent.style.whiteSpace = "pre-wrap";

        renderMessageParts(msg.content, messageContent);

        if (msg.role === "user") {
          const footerDiv = document.createElement("div");
          footerDiv.style.display = "flex";
          footerDiv.style.gap = "8px";
          footerDiv.style.marginTop = "6px";
          footerDiv.style.justifyContent = "flex-end";
          footerDiv.style.opacity = "0.7";

          // Revert Button
          const revertBtn = document.createElement("button");
          revertBtn.title = "Revert to here";
          revertBtn.style.background = "none";
          revertBtn.style.border = "none";
          revertBtn.style.color = "inherit";
          revertBtn.style.cursor = "pointer";
          revertBtn.style.padding = "2px";
          revertBtn.style.display = "flex";
          revertBtn.style.alignItems = "center";
          revertBtn.innerHTML = `<svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>`;
          revertBtn.onclick = () => revertToMessage(msg.uniqueId);

          // Copy Button
          const copyBtn = document.createElement("button");
          copyBtn.title = "Copy message";
          copyBtn.style.background = "none";
          copyBtn.style.border = "none";
          copyBtn.style.color = "inherit";
          copyBtn.style.cursor = "pointer";
          copyBtn.style.padding = "2px";
          copyBtn.style.display = "flex";
          copyBtn.style.alignItems = "center";
          copyBtn.innerHTML = `<svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>`;

          copyBtn.onclick = () => {
            vscode.postMessage({
              command: "copyToClipboard",
              text: msg.content,
            });
            const originalHTML = copyBtn.innerHTML;
            copyBtn.innerHTML = `<svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`;
            setTimeout(() => {
              copyBtn.innerHTML = originalHTML;
            }, 1000);
          };

          footerDiv.appendChild(revertBtn);
          footerDiv.appendChild(copyBtn);
          messageContent.appendChild(footerDiv);
        }

        messageDiv.appendChild(messageContent);
        chatContainer.appendChild(messageDiv);
        content.scrollTop = content.scrollHeight;
      }

      function reattachEventListeners() {
        // Re-attach listeners for Revert buttons
        const revertBtns = document.querySelectorAll(
          'button[title="Revert to here"]',
        );
        revertBtns.forEach((btn) => {
          // Find the parent message bubble to get the ID
          // Structure: button -> footerDiv -> messageContent -> messageDiv
          // messageContent has the ID
          const messageContent = btn.closest(".message-bubble");
          if (messageContent && messageContent.id) {
            btn.onclick = () => revertToMessage(messageContent.id);
          }
        });

        // Re-attach listeners for Copy buttons
        const copyBtns = document.querySelectorAll(
          'button[title="Copy message"]',
        );
        copyBtns.forEach((btn) => {
          const messageContent = btn.closest(".message-bubble");
          if (messageContent) {
            btn.onclick = () => {
              // Fallback to innerText since we don't have the original markdown
              // We could try to reconstruct it, but innerText is safer than nothing
              vscode.postMessage({
                command: "copyToClipboard",
                text: messageContent.innerText
                  .replace(/Revert to here|Copy message/g, "")
                  .trim(), // Basic cleanup
              });
              const originalHTML = btn.innerHTML;
              btn.innerHTML = `<svg style="width: 16px; height: 16px;" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>`;
              setTimeout(() => {
                btn.innerHTML = originalHTML;
              }, 1000);
            };
          }
        });
      }

      function revertToMessage(messageId) {
        const index = messageArray.findIndex((m) => m.uniqueId === messageId);
        if (index === -1) return;

        if (
          !confirm(
            "Are you sure you want to revert to this point? All subsequent changes will be undone.",
          )
        ) {
          return;
        }

        // We want to keep the current message and its immediate response (if any)
        // Usually User -> Assistant. So keep index and index + 1.
        // But if the user clicks revert on the *User* message, they expect to go back to the state *after* this interaction?
        // "jika user klik revert di chat pertama, maka chat ke 2 dan 3 ... akan hilang".
        // Chat 1 = User Request + Agent Response.
        // So keep User Request (index) + Agent Response (index + 1).

        const targetIndex = index + 1; // Keep up to this index (inclusive)

        // Collect changes to revert (in reverse order)
        const changesToRevert = [];
        for (let i = messageArray.length - 1; i > targetIndex; i--) {
          const msg = messageArray[i];
          if (msg.changes && msg.changes.length > 0) {
            // Add changes in reverse order of application?
            // Actually, just add them. The backend handles reverting a list of changes.
            // But if multiple changes to same file, order matters.
            // If msg.changes is [C1, C2], we should revert C2 then C1?
            // The backend `revertChanges` iterates the array.
            // So we should push in reverse order: C2, C1.
            // msg.changes stores [C1, C2] in order of application.
            // So to revert, we need [C2, C1].
            changesToRevert.push(...[...msg.changes].reverse());
          }
        }

        if (changesToRevert.length > 0) {
          vscode.postMessage({
            command: "revertChanges",
            changes: changesToRevert,
          });
        }

        // Truncate message array
        messageArray = messageArray.slice(0, targetIndex + 1);

        // Update UI
        saveState();

        // Re-render
        const content = document.getElementById("content");
        content.innerHTML = "";
        const chatContainer = document.createElement("div");
        chatContainer.id = "chat-container";
        chatContainer.className = "custom-scrollbar";
        content.appendChild(chatContainer);

        messageArray.forEach((msg) => displayMessagesAssistant(msg));
      }

      function updateMessagesAssistant(msg) {
        const messageContent = document.getElementById(msg.uniqueId);
        if (!messageContent) return;
        messageContent.innerHTML = "";
        renderMessageParts(msg.content, messageContent);
      }

      window.keepAllModifiedFiles = (filePaths) => {
        const filesData = [];
        filePaths.forEach((path) => {
          const content = window.fileContentMap.get(path);
          if (content) {
            filesData.push({ filePath: path, code: content });
          }
        });

        if (filesData.length > 0) {
          vscode.postMessage({
            command: "keepAllModifiedFiles",
            files: filesData,
          });
        } else {
          console.error("No content found for files:", filePaths);
        }
      };

      function renderMessageParts(content, container) {
        const parts = content.split(
          /(```[\s\S]*?```|`[^`]+`|\[selection\][\s\S]*?\[selection\]|\[fullcode\][\s\S]*?\[fullcode\]|\[labelInstruction\][\s\S]*?\[labelInstruction\]|\[files\][\s\S]*?\[files\]|\[file name=".*?"\][\s\S]*?\[\/file\]|\[openDiff path=".*?"\]|\[keepAllFiles files=".*?"\]|\[att-img .*?\]|\[att-file .*?\]|\[file\][\s\S]*?\[file\]|\[status\][\s\S]*?\[\/status\]|\[thinking[\s\S]*?\[\/thinking\]|\*\*[^*]+\*\*|\*\"[^*]+\*|_([^_]+)_|>.*|(\[.*?\]\(.*?\))|####.*|###.*|##.*|#.*|^- .*)/gm,
        );

        parts
          .filter((part) => part)
          .forEach((part, i) => {
            if (
              part.startsWith("[selection]") &&
              part.endsWith("[selection]")
            ) {
              //skip
            } else if (part.startsWith('[file name="')) {
              // Updated Regex to handle multiple lines properly
              const match = part.match(
                /\[file name="([^"]+)"\]([\s\S]*?)\[\/file\]/,
              );
              if (match) {
                // If it's a file block, we should not render it as text, but we must save it to the map
                const fPath = match[1];
                const fContent = match[2];
                window.fileContentMap.set(fPath, fContent);
                console.log(
                  `[webview] Render pass: Stored content for ${fPath}`,
                );
              }
            } else if (part.startsWith('[keepAllFiles files="')) {
              const match = part.match(/\[keepAllFiles files="(.*?)"\]/);
              if (match) {
                const filePaths = match[1].split(",");
                const btn = document.createElement("button");
                btn.className = "btn-diff";
                btn.style.backgroundColor = "#238636";
                btn.style.color = "white";
                btn.style.marginBottom = "10px";
                btn.innerHTML = `<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg> Keep All Modified Files`;
                btn.onclick = () => window.keepAllModifiedFiles(filePaths);
                container.appendChild(btn);
              }
            } else if (part.startsWith('[openDiff path="')) {
              const match = part.match(/\[openDiff path="(.*?)"\]/);
              if (match) {
                const btn = document.createElement("button");
                btn.className = "btn-diff";
                btn.innerHTML = `<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7v8a2 2 0 002 2h6M8 7V5a2 2 0 012-2h4.586a1 1 0 01.707.293l4.414 4.414a1 1 0 01.293.707V15a2 2 0 01-2 2h-2M8 7H6a2 2 0 00-2 2v10a2 2 0 002 2h8a2 2 0 002-2v-2"></path></svg> Open Diff: ${match[1]}`;
                btn.onclick = () => window.openDiff(match[1]);
                container.appendChild(btn);
              }
            } else if (part.startsWith("[att-img ")) {
              const match = part.match(/\[att-img name="(.*?)" src="(.*?)"\]/);
              if (match) {
                const wrapper = document.createElement("div");
                wrapper.style.display = "inline-block";
                wrapper.style.width = "60px";
                wrapper.style.height = "60px";
                wrapper.style.overflow = "hidden";
                wrapper.style.borderRadius = "6px";
                wrapper.style.border = "1px solid #e5e7eb";
                wrapper.style.marginRight = "8px";
                const img = document.createElement("img");
                img.src = match[2];
                img.alt = match[1];
                img.style.width = "100%";
                img.style.height = "100%";
                img.style.objectFit = "cover";
                wrapper.appendChild(img);
                container.appendChild(wrapper);
              }
            } else if (part.startsWith("[att-file ")) {
              const match = part.match(/\[att-file name="(.*?)"\]/);
              if (match) {
                const btn = document.createElement("button");
                btn.className = "btn-diff";
                btn.style.marginRight = "8px";
                btn.innerHTML = `<svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 3h6l5 5v11a2 2 0 01-2 2H7a2 2 0 01-2-2V5a2 2 0 012-2z" /></svg> Attachment: ${match[1]}`;
                container.appendChild(btn);
              }
            } else if (
              part.startsWith("[fullcode]") &&
              part.endsWith("[fullcode]")
            ) {
              //skip
            } else if (
              part.startsWith("[labelInstruction]") &&
              part.endsWith("[labelInstruction]")
            ) {
              //skip
            } else if (part.startsWith("[files]") && part.endsWith("[files]")) {
              //skip
            } else if (
              part.startsWith("[status]") &&
              part.endsWith("[/status]")
            ) {
              const statusContent = part.slice(8, -9).trim();
              const statusDiv = document.createElement("div");
              statusDiv.className = "status-box";
              statusDiv.innerHTML = `<span class="status-label">STATUS</span>${statusContent}`;
              container.appendChild(statusDiv);
            } else if (
              part.startsWith("[thinking") &&
              part.endsWith("[/thinking]")
            ) {
              const match = part.match(
                /\[thinking title="(.*?)"\]([\s\S]*?)\[\/thinking\]/,
              );
              if (match) {
                const title = match[1];
                const content = match[2];
                const details = document.createElement("details");

                const summary = document.createElement("summary");
                summary.textContent = title;
                details.appendChild(summary);

                const contentDiv = document.createElement("div");
                renderMessageParts(content, contentDiv);
                details.appendChild(contentDiv);

                container.appendChild(details);
              }
            } else if (part.startsWith("[file]") && part.endsWith("[file]")) {
              const textSpan = document.createElement("span");
              textSpan.textContent = "--File--";
              container.appendChild(textSpan);
            } else if (part.startsWith("```") && part.endsWith("```")) {
              let codeContent = part.slice(3, -3).trim();

              const codeLines = codeContent.split("\n");
              const firstLine = codeLines[0].trim();
              const languageRegex =
                /^(nginx|dockerfile|javascript|js|typescript|ts|python|java|c\+\+|cpp|c#|cs|ruby|go|php|swift|kotlin|json|jsx|tsx|html|css|xml|c|rust|perl|r|bash|shell|cmd|powershell|yml|yaml|markdown|md|lua|dart|sql|ini|toml|env|vue|svelte|makefile|plaintext|text|txt)$/i;

              if (languageRegex.test(firstLine)) {
                codeContent = codeLines.slice(1).join("\n").trim(); // Remove the first line if it matches a language
              }

              const codeDiv = document.createElement("div");
              codeDiv.className = "p-2 rounded-lg mb-2 wrap";

              const pre = document.createElement("pre");

              const code = document.createElement("code");
              code.className = `language-${firstLine}`; // Menambahkan kelas bahasa
              code.textContent = codeContent;
              pre.appendChild(code);

              codeDiv.appendChild(pre);

              Prism.highlightElement(code);

              const modeSelect = document.getElementById("modeSelect");
              const isAgentMode = modeSelect && modeSelect.value === "agent";

              if (!isAgentMode) {
                const copyButton = document.createElement("button");
                copyButton.textContent = "Copy";
                copyButton.className = "mt-2 btn-primary px-2 py-1 text-xs";
                copyButton.onclick = () => handleCopy(codeContent);
                codeDiv.appendChild(copyButton);

                const applyButton = document.createElement("button");
                applyButton.textContent = "Apply";
                applyButton.className =
                  "mt-2 btn-elegant px-2 py-1 ml-2 text-xs";
                applyButton.onclick = () => handleaApply(codeContent);
                codeDiv.appendChild(applyButton);
              }

              container.appendChild(codeDiv);
            } else if (part.startsWith("`") && part.endsWith("`")) {
              const inlineCode = part.slice(1, -1);
              const codeSpan = document.createElement("code");
              codeSpan.className =
                "bg-black text-white p-1 rounded border border-gray-700";
              codeSpan.textContent = inlineCode;
              container.appendChild(codeSpan);
            } else if (part.startsWith("**") && part.endsWith("**")) {
              // Cek Bold & Badges
              const text = part.slice(2, -2).trim();
              const upper = text.toUpperCase();

              if (
                [
                  "THOUGHT:",
                  "ACTION:",
                  "REASONING:",
                  "PLAN:",
                  "ERROR:",
                  "STEP",
                ].some((k) => upper.startsWith(k))
              ) {
                const span = document.createElement("div");
                span.className = "badge-header";
                if (upper.includes("THOUGHT"))
                  span.classList.add("badge-thought");
                else if (upper.includes("ACTION"))
                  span.classList.add("badge-action");
                else if (upper.includes("REASONING"))
                  span.classList.add("badge-reasoning");
                else if (upper.includes("PLAN"))
                  span.classList.add("badge-plan");
                else if (upper.includes("ERROR"))
                  span.classList.add("badge-error");

                span.innerHTML = text;
                container.appendChild(span);
              } else {
                const textStrong = document.createElement("strong");
                textStrong.textContent = text;
                container.appendChild(textStrong);
              }
            } else if (part.startsWith("###")) {
              // Cek header
              part = part.slice(3).trim();
              const textHeader = document.createElement("h3");
              textHeader.style =
                "font-weight: bold; font-size:14px; margin-top:10px;";
              textHeader.textContent = part;
              container.appendChild(textHeader);
            } else if (part.startsWith("##")) {
              // Cek header
              part = part.slice(2).trim();
              const textHeader = document.createElement("h2");
              textHeader.style =
                "font-weight: bold; font-size:16px; margin-top:12px;";
              textHeader.textContent = part;
              container.appendChild(textHeader);
            } else if (part.startsWith("#")) {
              // Cek header
              part = part.slice(1).trim();
              const textHeader = document.createElement("h1");
              textHeader.style =
                "font-weight: bold; font-size:18px; margin-top:14px;";
              textHeader.textContent = part;
              container.appendChild(textHeader);
            } else if (part.startsWith("- ")) {
              const listItem = part.slice(2);
              if (listItem.match(/^\[[ xðŸ”„âœ…âŒ]\]\s*Step\s+\d+:/)) {
                const textSpan = document.createElement("span");
                textSpan.textContent = part;
                container.appendChild(textSpan);
                container.appendChild(document.createElement("br"));
              } else {
                const partsList = listItem.split(
                  /(\*\*[^*]+\*\*|\*\"[^*]+\*|_([^_]+)_|>.*|(\[.*?\]\(.*?\))|###.*|##.*|#.*|^- .*)/gm,
                );

                const textLi = document.createElement("li");
                partsList
                  .filter((partList) => partList)
                  .map((partList, i2) => {
                    if (partList.startsWith("**") && partList.endsWith("**")) {
                      partList = partList.slice(2, -2);
                      const textStrong = document.createElement("strong");
                      textStrong.textContent = partList;
                      textLi.appendChild(textStrong);
                    } else {
                      const text = document.createElement("span");
                      text.textContent = partList;
                      textLi.appendChild(text);
                    }
                  });
                container.appendChild(textLi);
              }
            } else if (part.startsWith("_") && part.endsWith("_")) {
              const italicText = part.slice(1, -1);
              const textEm = document.createElement("em");
              textEm.textContent = italicText;
              container.appendChild(textEm);
            } else if (part.startsWith('*"') && part.startsWith("*")) {
              // Quote Style 1
              const quoteText = part.slice(1, -1).trim();
              const quote = document.createElement("div");
              quote.className = "modern-blockquote";
              quote.textContent = quoteText;
              container.appendChild(quote);
            } else if (part.startsWith(">")) {
              // Quote Style 2 (Standard Markdown)
              const quoteText = part.slice(1).trim();
              const quote = document.createElement("div");
              quote.className = "modern-blockquote";
              quote.textContent = quoteText;
              container.appendChild(quote);
            } else if (/\[.*?\]\(.*?\)/.test(part)) {
              const linkMatch = part.match(/\[(.*?)\]\((.*?)\)/);
              if (linkMatch) {
                const linkText = linkMatch[1];
                const linkUrl = linkMatch[2];
                const link = document.createElement("a");
                link.textContent = linkText;
                link.href = linkUrl;
                container.appendChild(link);
              }
            } else {
              const textSpan = document.createElement("span");
              textSpan.textContent = part;
              container.appendChild(textSpan);
            }
          });
      }

      function handleCopy(code) {
        navigator.clipboard.writeText(code).then(() => {
          alert("Copied!");
        });
      }
      function handleaApply(code, filePath = null) {
        vscode.postMessage({
          command: "applyCodeSelection",
          code: code,
          filePath: filePath,
        });
      }

      function logout() {
        console.log("Logging out...");
        localStorage.removeItem("token");
        localStorage.removeItem("userId");
        const allCodeStorageKey = "allCodeStorage";
        const codingStorageKey = "codingStorage";
        localStorage.removeItem(allCodeStorageKey);
        localStorage.removeItem(codingStorageKey);

        // Clear state
        vscode.setState(undefined);

        // Clear message array and content
        messageArray = [];
        document.getElementById("content").innerHTML = "";

        // Reset persisted state explicitly
        if (persistedState) {
          persistedState.messagesHTML = "";
          persistedState.input = "";
          persistedState.messages = [];
        }

        showLoginForm();
      }

      window.fileContentMap = new Map();
      window.keepAllModifiedFiles = function (filePaths) {
        // Collect files and their content
        const files = filePaths.map((path) => {
          return {
            filePath: path,
            code: window.fileContentMap.get(path) || "",
          };
        });

        // Send message to extension
        vscode.postMessage({
          command: "keepAllModifiedFiles",
          files: files,
        });
      };
      window.openDiff = function (path) {
        const code = window.fileContentMap.get(path);
        if (code) {
          handleaApply(code, path);
        } else {
          console.log("Diff content not found for " + path);
        }
      };
    </script>
    <script src="%PRISMJS_PATH%"></script>
    <!-- Include the Prism JS for syntax highlighting functionality -->
  </body>
</html>
